{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst entity_1 = require(\"../entity\");\n\nconst sanitize_1 = require(\"../utils/sanitize\");\n\nconst closeable_1 = require(\"../closeable\");\n\nclass SyncStreamImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n    this.descriptor = descriptor;\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  static get type() {\n    return 'stream';\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  get type() {\n    return 'stream';\n  }\n\n  get lastEventId() {\n    return null;\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  async publishMessage(value) {\n    const requestBody = {\n      data: value\n    };\n    const response = await this.services.network.post(this.links.messages, requestBody);\n    const responseBody = response.body;\n\n    const event = this._handleMessagePublished(responseBody.sid, value, false);\n\n    return event;\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl: ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async removeStream() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n  /**\n   * Handle event from the server\n   * @private\n   */\n\n\n  _update(update) {\n    switch (update.type) {\n      case 'stream_message_published':\n        {\n          this._handleMessagePublished(update.message_sid, update.message_data, true);\n\n          break;\n        }\n\n      case 'stream_removed':\n        {\n          this.onRemoved(false);\n          break;\n        }\n    }\n  }\n\n  _handleMessagePublished(sid, data, remote) {\n    const event = {\n      sid: sid,\n      value: data\n    };\n    this.broadcastEventToListeners('messagePublished', {\n      message: event,\n      isLocal: !remote\n    });\n    return event;\n  }\n\n  onRemoved(isLocal) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: isLocal\n    });\n  }\n\n}\n\nexports.SyncStreamImpl = SyncStreamImpl;\n/**\n * @class\n * @alias Stream\n * @classdesc A Sync primitive for pub-sub messaging. Stream Messages are not persisted, exist\n *     only in transit, and will be dropped if (due to congestion or network anomalies) they\n *     cannot be delivered promptly. Use the {@link Client#stream} method to obtain a reference to a Sync Message Stream.\n * @property {String} sid The immutable system-assigned identifier of this stream. Never null.\n * @property {String} [uniqueName=null] A unique identifier optionally assigned to the stream on creation.\n *\n * @fires Stream#messagePublished\n * @fires Stream#removed\n */\n\nclass SyncStream extends closeable_1.default {\n  // private props\n  get uri() {\n    return this.syncStreamImpl.uri;\n  }\n\n  get links() {\n    return this.syncStreamImpl.links;\n  }\n\n  static get type() {\n    return SyncStreamImpl.type;\n  }\n\n  get dateExpires() {\n    return this.syncStreamImpl.dateExpires;\n  }\n\n  get type() {\n    return SyncStreamImpl.type;\n  }\n\n  get lastEventId() {\n    return null;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncStreamImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncStreamImpl.uniqueName;\n  }\n\n  constructor(syncStreamImpl) {\n    super();\n    this.syncStreamImpl = syncStreamImpl;\n    this.syncStreamImpl.attach(this);\n  }\n  /**\n   * Publish a Message to the Stream. The system will attempt delivery to all online subscribers.\n   * @param {Object} value The body of the dispatched message. Maximum size in serialized JSON: 4KB.\n   * A rate limit applies to this operation, refer to the [Sync API documentation]{@link https://www.twilio.com/docs/api/sync} for details.\n   * @return {Promise<StreamMessage>} A promise which resolves after the message is successfully published\n   *   to the Sync service. Resolves irrespective of ultimate delivery to any subscribers.\n   * @public\n   * @example\n   * stream.publishMessage({ x: 42, y: 123 })\n   *   .then(function(message) {\n   *     console.log('Stream publishMessage() successful, message SID:' + message.sid);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Stream publishMessage() failed', error);\n   *   });\n   */\n\n\n  async publishMessage(value) {\n    this.ensureNotClosed();\n    return this.syncStreamImpl.publishMessage(value);\n  }\n  /**\n   * Update the time-to-live of the stream.\n   * @param {Number} ttl Specifies the TTL in seconds after which the stream is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * stream.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Stream setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Stream setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncStreamImpl.setTtl(ttl);\n  }\n  /**\n   * Permanently delete this Stream.\n   * @return {Promise<void>} A promise which resolves after the Stream is successfully deleted.\n   * @public\n   * @example\n   * stream.removeStream()\n   *   .then(function() {\n   *     console.log('Stream removeStream() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Stream removeStream() failed', error);\n   *   });\n   */\n\n\n  async removeStream() {\n    this.ensureNotClosed();\n    return this.syncStreamImpl.removeStream();\n  }\n  /**\n   * Conclude work with the stream instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this stream will continue operating and receiving events normally.\n   * @public\n   * @example\n   * stream.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncStreamImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncStream = SyncStream;\nexports.default = SyncStream;\n/**\n * @class StreamMessage\n * @classdesc Stream Message descriptor.\n * @property {String} sid Contains Stream Message SID.\n * @property {Object} value Contains Stream Message value.\n */\n\n/**\n * Fired when a Message is published to the Stream either locally or by a remote actor.\n * @event Stream#messagePublished\n * @param {Object} args Arguments provided with the event.\n * @param {StreamMessage} args.message Published message.\n * @param {Boolean} args.isLocal Equals 'true' if message was published by local code, 'false' otherwise.\n * @example\n * stream.on('messagePublished', function(args) {\n *   console.log('Stream message published');\n *   console.log('Message SID: ' + args.message.sid);\n *   console.log('Message value: ', args.message.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a stream is removed entirely, whether the remover was local or remote.\n * @event Stream#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if stream was removed by local code, 'false' otherwise.\n * @example\n * stream.on('removed', function(args) {\n *   console.log('Stream ' + stream.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":null,"metadata":{},"sourceType":"script"}