{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass Node {\n  constructor(key, value) {\n    this.balanceFactor = 0;\n    this.key = key;\n    this.value = value;\n    this.parent = null;\n    this.left = null;\n    this.right = null;\n  }\n\n  get isRoot() {\n    return this.parent === null;\n  }\n\n  get isLeaf() {\n    return this.left === null && this.right === null;\n  }\n\n  get isLeftChild() {\n    return this.parent.left === this;\n  }\n\n  update(value) {\n    this.value = value;\n  }\n\n  replace(target, replacement) {\n    if (!target) {\n      return;\n    }\n\n    if (this.left === replacement) {\n      this.left = replacement;\n    } else if (this.right === replacement) {\n      this.right = replacement;\n    }\n  }\n\n}\n/**\n * @property length\n */\n\n\nclass TreeMap {\n  constructor(less, equal) {\n    this.isLessThan = less || ((x, y) => x < y);\n\n    this.isEqual = equal || ((x, y) => x === y);\n\n    this.root = null;\n    this.count = null;\n  }\n\n  get size() {\n    return this.count;\n  }\n\n  clear() {\n    this.root = null;\n    this.count = 0;\n  }\n\n  set(key, value) {\n    let node = this.getNode(key);\n\n    if (node) {\n      node.update(value);\n    } else {\n      this.insert(key, value);\n    } // return node;\n\n  }\n\n  insert(key, value) {\n    let node = new Node(key, value);\n    this.count++;\n\n    if (!this.root) {\n      this.root = node; // return node;\n\n      return;\n    }\n\n    let currNode = this.root;\n\n    for (;;) {\n      if (this.isLessThan(key, currNode.key)) {\n        if (currNode.left) {\n          currNode = currNode.left;\n        } else {\n          currNode.left = node;\n          break;\n        }\n      } else {\n        if (currNode.right) {\n          // eslint-disable-line no-lonely-if\n          currNode = currNode.right;\n        } else {\n          currNode.right = node;\n          break;\n        }\n      }\n    }\n\n    node.parent = currNode;\n    currNode = node;\n\n    while (currNode.parent) {\n      let parent = currNode.parent;\n      let prevBalanceFactor = parent.balanceFactor;\n\n      if (currNode.isLeftChild) {\n        parent.balanceFactor++;\n      } else {\n        parent.balanceFactor--;\n      }\n\n      if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {\n        break;\n      }\n\n      if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n        this.rebalance(parent);\n        break;\n      }\n\n      currNode = parent;\n    } // return node;\n\n  }\n\n  get(key) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key)) {\n        return currentNode.value;\n      }\n\n      if (this.isLessThan(key, currentNode.key)) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    return null;\n  }\n\n  delete(key) {\n    // update this algorithm and remove any\n    let node = this.getNode(key);\n\n    if (!node || node.key !== key) {\n      return null;\n    }\n\n    let parent = node.parent;\n    let left = node.left;\n    let right = node.right;\n\n    if (!!left !== !!right) {\n      // one child\n      let child = left || right;\n\n      if (!parent && !child) {\n        this.root = null;\n      } else if (parent && !child) {\n        this.root = child;\n      } else {\n        parent.replace(node, null);\n        this.rebalance(parent);\n      }\n    } else {\n      // two children\n      let maxLeft = node.left;\n\n      while (maxLeft.right) {\n        maxLeft = maxLeft.right;\n      }\n\n      if (node.left === maxLeft) {\n        if (node.isRoot) {\n          this.root = maxLeft;\n          maxLeft.parent = null;\n        } else {\n          if (node.isLeftChild) {\n            node.parent.left = maxLeft;\n          } else {\n            node.parent.right = maxLeft;\n          }\n\n          maxLeft.parent = node.parent;\n        }\n\n        maxLeft.right = node.right;\n        maxLeft.right.parent = maxLeft;\n        maxLeft.balanceFactor = node.balanceFactor;\n        node = {\n          parent: maxLeft,\n          isLeftChild: true\n        };\n      } else {\n        let mlParent = maxLeft.parent;\n        let mlLeft = maxLeft.left;\n        mlParent.right = mlLeft;\n\n        if (mlLeft) {\n          mlLeft.parent = mlParent;\n        }\n\n        if (node.isRoot) {\n          this.root = maxLeft;\n          maxLeft.parent = null;\n        } else {\n          if (node.isLeftChild) {\n            node.parent.left = maxLeft;\n          } else {\n            node.parent.right = maxLeft;\n          }\n\n          maxLeft.parent = node.parent;\n        }\n\n        maxLeft.right = node.right;\n        maxLeft.right.parent = maxLeft;\n        maxLeft.left = node.left;\n        maxLeft.left.parent = maxLeft;\n        maxLeft.balanceFactor = node.balanceFactor;\n        node = {\n          parent: mlParent,\n          isLeftChild: false\n        };\n      }\n    }\n\n    this.count--;\n\n    while (node.parent) {\n      let parent = node.parent;\n      let prevBalanceFactor = parent.balanceFactor;\n\n      if (node.isLeftChild) {\n        parent.balanceFactor -= 1;\n      } else {\n        parent.balanceFactor += 1;\n      }\n\n      if (Math.abs(parent.balanceFactor) > Math.abs(prevBalanceFactor)) {\n        if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {\n          this.rebalance(parent);\n\n          if (parent.parent.balanceFactor === 0) {\n            node = parent.parent;\n          } else {\n            break;\n          }\n        } else {\n          break;\n        }\n      } else {\n        node = parent;\n      }\n    }\n\n    return null;\n  }\n\n  getNode(key) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key)) {\n        return currentNode;\n      }\n\n      if (this.isLessThan(key, currentNode.key)) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    return null;\n  }\n\n  rebalance(node) {\n    if (node.balanceFactor < 0) {\n      if (node.right.balanceFactor > 0) {\n        this.rotateRight(node.right);\n        this.rotateLeft(node);\n      } else {\n        this.rotateLeft(node);\n      }\n    } else if (node.balanceFactor > 0) {\n      if (node.left.balanceFactor < 0) {\n        this.rotateLeft(node.left);\n        this.rotateRight(node);\n      } else {\n        this.rotateRight(node);\n      }\n    }\n  }\n\n  rotateLeft(pivot) {\n    let root = pivot.right;\n    pivot.right = root.left;\n\n    if (root.left !== null) {\n      root.left.parent = pivot;\n    }\n\n    root.parent = pivot.parent;\n\n    if (root.parent === null) {\n      this.root = root;\n    } else if (pivot.isLeftChild) {\n      root.parent.left = root;\n    } else {\n      root.parent.right = root;\n    }\n\n    root.left = pivot;\n    pivot.parent = root;\n    pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);\n    root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);\n  }\n\n  rotateRight(pivot) {\n    let root = pivot.left;\n    pivot.left = root.right;\n\n    if (root.right !== null) {\n      root.right.parent = pivot;\n    }\n\n    root.parent = pivot.parent;\n\n    if (root.parent === null) {\n      this.root = root;\n    } else if (pivot.isLeftChild) {\n      root.parent.left = root;\n    } else {\n      root.parent.right = root;\n    }\n\n    root.right = pivot;\n    pivot.parent = root;\n    pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);\n    root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);\n  }\n\n  *[Symbol.iterator]() {\n    for (let iter of this.getIterator()) {\n      yield iter;\n    }\n  }\n\n  *getIterator(key = null) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key) || key === null && !currentNode.left) {\n        break;\n      }\n\n      if (this.isLessThan(key, currentNode.key) || key === null) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (!currentNode) {\n      return null;\n    }\n\n    let fromleft = true;\n\n    for (;;) {\n      if (fromleft) {\n        yield [currentNode.key, currentNode.value];\n        fromleft = false;\n\n        if (currentNode.right) {\n          currentNode = currentNode.right;\n\n          while (currentNode.left) {\n            currentNode = currentNode.left;\n          }\n\n          fromleft = true;\n        } else if (currentNode.parent) {\n          fromleft = currentNode.parent.left === currentNode;\n          currentNode = currentNode.parent;\n        } else {\n          break;\n        }\n      } else if (currentNode.parent) {\n        fromleft = currentNode.parent.left === currentNode;\n        currentNode = currentNode.parent;\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n  *getReverseIterator(key = null) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (this.isEqual(key, currentNode.key) || key === null && !currentNode.right) {\n        break;\n      }\n\n      if (!this.isLessThan(key, currentNode.key) || key === null) {\n        currentNode = currentNode.right;\n      } else {\n        currentNode = currentNode.left;\n      }\n    }\n\n    if (!currentNode) {\n      return null;\n    }\n\n    let fromright = true;\n\n    for (;;) {\n      if (fromright) {\n        yield [currentNode.key, currentNode.value];\n        fromright = false;\n\n        if (currentNode.left) {\n          currentNode = currentNode.left;\n\n          while (currentNode.right) {\n            currentNode = currentNode.right;\n          }\n\n          fromright = true;\n        } else if (currentNode.parent) {\n          fromright = currentNode.parent.right === currentNode;\n          currentNode = currentNode.parent;\n        } else {\n          break;\n        }\n      } else if (currentNode.parent) {\n        fromright = currentNode.parent.right === currentNode;\n        currentNode = currentNode.parent;\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nexports.TreeMap = TreeMap;","map":null,"metadata":{},"sourceType":"script"}