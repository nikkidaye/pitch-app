{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst uuid = require(\"uuid\");\n\nconst syncerror_1 = require(\"../utils/syncerror\");\n\nconst logger_1 = require(\"../utils/logger\");\n\nconst operation_retrier_1 = require(\"operation-retrier\");\n\nconst twilsock_1 = require(\"twilsock\");\n\nconst MINIMUM_RETRY_DELAY = 4000;\nconst MAXIMUM_RETRY_DELAY = 60000;\nconst MAXIMUM_ATTEMPTS_TIME = 90000;\nconst RETRY_DELAY_RANDOMNESS = 0.2;\n\nfunction messageFromErrorBody(transportError) {\n  if (transportError.body) {\n    if (transportError.body.message) {\n      return transportError.body.message;\n    }\n  }\n\n  switch (transportError.status) {\n    case 429:\n      return 'Throttled by server';\n\n    case 404:\n      return 'Not found from server';\n\n    default:\n      return 'Error from server';\n  }\n}\n\nfunction codeFromErrorBody(trasportError) {\n  if (trasportError.body) {\n    return trasportError.body.code;\n  }\n\n  return 0;\n}\n\nfunction mapTransportError(transportError) {\n  if (transportError.status === 409) {\n    return new syncerror_1.SyncNetworkError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError), transportError.body);\n  } else if (transportError.status) {\n    return new syncerror_1.SyncError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError));\n  } else if (transportError instanceof twilsock_1.TransportUnavailableError) {\n    return transportError;\n  } else {\n    return new syncerror_1.SyncError(transportError.message, 0, 0);\n  }\n}\n/**\n * @classdesc Incapsulates network operations to make it possible to add some optimization/caching strategies\n */\n\n\nclass NetworkService {\n  constructor(clientInfo, config, transport) {\n    this.clientInfo = clientInfo;\n    this.config = config;\n    this.transport = transport;\n  }\n\n  createHeaders() {\n    return {\n      'Content-Type': 'application/json',\n      'Twilio-Sync-Client-Info': JSON.stringify(this.clientInfo),\n      'Twilio-Request-Id': 'RQ' + uuid.v4().replace(/-/g, '')\n    };\n  }\n\n  backoffConfig() {\n    return Object.assign({\n      min: MINIMUM_RETRY_DELAY,\n      max: MAXIMUM_RETRY_DELAY,\n      maxAttemptsTime: MAXIMUM_ATTEMPTS_TIME,\n      randomness: RETRY_DELAY_RANDOMNESS\n    }, this.config.backoffConfig);\n  }\n\n  executeWithRetry(request, retryWhenThrottled = true) {\n    return new Promise((resolve, reject) => {\n      let codesToRetryOn = [502, 503, 504];\n\n      if (retryWhenThrottled) {\n        codesToRetryOn.push(429);\n      }\n\n      let retrier = new operation_retrier_1.Retrier(this.backoffConfig());\n      retrier.on('attempt', () => {\n        request().then(result => retrier.succeeded(result)).catch(err => {\n          if (codesToRetryOn.includes(err.status)) {\n            let delayOverride = parseInt(err.headers ? err.headers['Retry-After'] : null);\n            retrier.failed(mapTransportError(err), isNaN(delayOverride) ? null : delayOverride * 1000);\n          } else if (err.message === 'Twilsock disconnected') {\n            // Ugly hack. We must make a proper exceptions for twilsock\n            retrier.failed(mapTransportError(err));\n          } else {\n            // Fatal error\n            retrier.removeAllListeners();\n            retrier.cancel();\n            reject(mapTransportError(err));\n          }\n        });\n      });\n      retrier.on('succeeded', result => {\n        resolve(result);\n      });\n      retrier.on('cancelled', err => reject(mapTransportError(err)));\n      retrier.on('failed', err => reject(mapTransportError(err)));\n      retrier.start();\n    });\n  }\n  /**\n   * Make a GET request by given URI\n   * @Returns Promise<Response> Result of successful get request\n   */\n\n\n  get(uri) {\n    let headers = this.createHeaders();\n    logger_1.default.debug('GET', uri, 'ID:', headers['Twilio-Request-Id']);\n    return this.executeWithRetry(() => this.transport.get(uri, headers), true);\n  }\n\n  post(uri, body, revision, retryWhenThrottled = false) {\n    let headers = this.createHeaders();\n\n    if (typeof revision !== 'undefined' && revision !== null) {\n      headers['If-Match'] = revision;\n    }\n\n    logger_1.default.debug('POST', uri, 'ID:', headers['Twilio-Request-Id']);\n    return this.executeWithRetry(() => this.transport.post(uri, headers, body), retryWhenThrottled);\n  }\n\n  put(uri, body, revision) {\n    let headers = this.createHeaders();\n\n    if (typeof revision !== 'undefined' && revision !== null) {\n      headers['If-Match'] = revision;\n    }\n\n    logger_1.default.debug('PUT', uri, 'ID:', headers['Twilio-Request-Id']);\n    return this.executeWithRetry(() => this.transport.put(uri, headers, body), false);\n  }\n\n  delete(uri) {\n    let headers = this.createHeaders();\n    logger_1.default.debug('DELETE', uri, 'ID:', headers['Twilio-Request-Id']);\n    return this.executeWithRetry(() => this.transport.delete(uri, headers), false);\n  }\n\n}\n\nexports.NetworkService = NetworkService;","map":null,"metadata":{},"sourceType":"script"}