{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"./logger\");\n\nconst uuid_1 = require(\"uuid\");\n\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\n\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nconst parser_1 = require(\"./parser\");\n\nconst Messages = require(\"./protocol/messages\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst REQUEST_TIMEOUT = 30000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nclass PacketRequest {}\n\nclass PacketResponse {}\n\nexports.PacketResponse = PacketResponse;\n\nclass PacketInterface {\n  constructor(channel, config) {\n    this.config = config;\n    this.activeRequests = new Map();\n    this.channel = channel;\n    this.channel.on('reply', reply => this.processReply(reply));\n    this.channel.on('disconnected', () => {\n      this.activeRequests.forEach(descriptor => {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\n      });\n      this.activeRequests.clear();\n    });\n  }\n\n  get isConnected() {\n    return this.channel.isConnected;\n  }\n\n  processReply(reply) {\n    const request = this.activeRequests.get(reply.id);\n\n    if (request) {\n      clearTimeout(request.timeout);\n      this.activeRequests.delete(reply.id);\n\n      if (!isHttpSuccess(reply.status.code)) {\n        request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\n        logger_1.log.trace('message rejected');\n      } else {\n        request.resolve(reply);\n      }\n    }\n  }\n\n  storeRequest(id, resolve, reject) {\n    let requestDescriptor = {\n      resolve: resolve,\n      reject: reject,\n      timeout: setTimeout(() => {\n        logger_1.log.trace('request', id, 'is timed out');\n        reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\n      }, REQUEST_TIMEOUT)\n    };\n    this.activeRequests.set(id, requestDescriptor);\n  }\n\n  shutdown() {\n    this.activeRequests.forEach(descriptor => {\n      clearTimeout(descriptor.timeout);\n      descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\n    });\n    this.activeRequests.clear();\n  }\n\n  async sendInit() {\n    logger_1.log.trace('sendInit');\n    let metadata = metadata_1.Metadata.getMetadata(this.config);\n    let message = new Messages.Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\n    let response = await this.sendWithReply(message);\n    return new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info);\n  }\n\n  sendClose() {\n    let message = new Messages.Close();\n    this.send(message);\n  }\n\n  sendWithReply(header, payload) {\n    return new Promise((resolve, reject) => {\n      let id = this.send(header, payload);\n      this.storeRequest(id, resolve, reject);\n    });\n  }\n\n  send(header, payload) {\n    header.id = header.id || \"TM\".concat(uuid_1.v4());\n    let message = parser_1.Parser.createPacket(header, preparePayload(payload));\n\n    try {\n      this.channel.send(message);\n      return header.id;\n    } catch (e) {\n      logger_1.log.debug('failed to send ', header, e);\n      logger_1.log.trace(e.stack);\n      throw e;\n    }\n  }\n\n}\n\nexports.PacketInterface = PacketInterface;","map":null,"metadata":{},"sourceType":"script"}