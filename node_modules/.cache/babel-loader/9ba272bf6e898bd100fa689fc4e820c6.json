{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n/**\n * Provides retrier service\n */\n\n\nclass Retrier extends events_1.EventEmitter {\n  /**\n   * Creates a new Retrier instance\n   */\n  constructor(options) {\n    super();\n    this.minDelay = options.min;\n    this.maxDelay = options.max;\n    this.initialDelay = options.initial || 0;\n    this.maxAttemptsCount = options.maxAttemptsCount || 0;\n    this.maxAttemptsTime = options.maxAttemptsTime || 0;\n    this.randomness = options.randomness || 0;\n    this.inProgress = false;\n    this.attemptNum = 0;\n    this.prevDelay = 0;\n    this.currDelay = 0;\n  }\n\n  attempt() {\n    clearTimeout(this.timeout);\n    this.attemptNum++;\n    this.timeout = null;\n    this.emit('attempt', this);\n  }\n\n  nextDelay(delayOverride) {\n    if (typeof delayOverride === 'number') {\n      this.prevDelay = 0;\n      this.currDelay = delayOverride;\n      return delayOverride;\n    }\n\n    if (this.attemptNum == 0) {\n      return this.initialDelay;\n    }\n\n    if (this.attemptNum == 1) {\n      this.currDelay = this.minDelay;\n      return this.currDelay;\n    }\n\n    this.prevDelay = this.currDelay;\n    let delay = this.currDelay + this.prevDelay;\n\n    if (this.maxDelay && delay > this.maxDelay) {\n      this.currDelay = this.maxDelay;\n      delay = this.maxDelay;\n    }\n\n    this.currDelay = delay;\n    return delay;\n  }\n\n  randomize(delay) {\n    let area = delay * this.randomness;\n    let corr = Math.round(Math.random() * area * 2 - area);\n    return Math.max(0, delay + corr);\n  }\n\n  scheduleAttempt(delayOverride) {\n    if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {\n      this.cleanup();\n      this.emit('failed', new Error('Maximum attempt count limit reached'));\n      this.reject(new Error('Maximum attempt count reached'));\n      return;\n    }\n\n    let delay = this.nextDelay(delayOverride);\n    delay = this.randomize(delay);\n\n    if (this.maxAttemptsTime && this.startTimestamp + this.maxAttemptsTime < Date.now() + delay) {\n      this.cleanup();\n      this.emit('failed', new Error('Maximum attempt time limit reached'));\n      this.reject(new Error('Maximum attempt time limit reached'));\n      return;\n    }\n\n    this.timeout = setTimeout(() => this.attempt(), delay);\n  }\n\n  cleanup() {\n    clearTimeout(this.timeout);\n    this.timeout = null;\n    this.inProgress = false;\n    this.attemptNum = 0;\n    this.prevDelay = 0;\n    this.currDelay = 0;\n  }\n\n  start() {\n    if (this.inProgress) {\n      throw new Error('Retrier is already in progress');\n    }\n\n    this.inProgress = true;\n    return new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      this.startTimestamp = Date.now();\n      this.scheduleAttempt(this.initialDelay);\n    });\n  }\n\n  cancel() {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n      this.inProgress = false;\n      this.emit('cancelled');\n      this.reject(new Error('Cancelled'));\n    }\n  }\n\n  succeeded(arg) {\n    this.emit('succeeded', arg);\n    this.resolve(arg);\n  }\n\n  failed(err, nextAttemptDelayOverride) {\n    if (this.timeout) {\n      throw new Error('Retrier attempt is already in progress');\n    }\n\n    this.scheduleAttempt(nextAttemptDelayOverride);\n  }\n\n  run(handler) {\n    this.on('attempt', () => {\n      handler().then(v => this.succeeded(v)).catch(e => this.failed(e));\n    });\n    return this.start();\n  }\n\n}\n\nexports.Retrier = Retrier;\nexports.default = Retrier;","map":null,"metadata":{},"sourceType":"script"}