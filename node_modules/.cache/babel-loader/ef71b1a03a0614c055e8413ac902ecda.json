{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst operation_retrier_1 = require(\"operation-retrier\");\n/**\n * Retrier with backoff override capability\n*/\n\n\nclass BackoffRetrier extends events_1.EventEmitter {\n  get inProgress() {\n    return !!this.retrier;\n  }\n\n  constructor(options) {\n    super();\n    this.options = options ? Object.assign({}, options) : {};\n  }\n  /**\n   * Should be called once per attempt series to start retrier.\n  */\n\n\n  start() {\n    if (this.inProgress) {\n      throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\n    }\n\n    this.createRetrier();\n  }\n  /**\n   * Should be called to stop retrier entirely.\n  */\n\n\n  stop() {\n    this.cleanRetrier();\n    this.newBackoff = null;\n    this.usedBackoff = null;\n  }\n  /**\n   * Modifies backoff for next attempt.\n   * Expected behavior:\n   * - If there was no backoff passed previously reschedulling next attempt to given backoff\n   * - If previous backoff was longer then ignoring this one.\n   * - If previous backoff was shorter then reschedulling with this one.\n   * With or without backoff retrier will keep growing normally.\n   * @param delay delay of next attempts in ms.\n   */\n\n\n  modifyBackoff(delay) {\n    this.newBackoff = delay;\n  }\n  /**\n   * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n  */\n\n\n  attemptFailed() {\n    if (!this.inProgress) {\n      throw new Error('No attempt is in progress');\n    }\n\n    if (this.newBackoff) {\n      const shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n\n      if (shouldUseNewBackoff) {\n        this.createRetrier();\n      } else {\n        this.retrier.failed(new Error());\n      }\n    } else {\n      this.retrier.failed(new Error());\n    }\n  }\n\n  cancel() {\n    if (this.retrier) {\n      this.retrier.cancel();\n    }\n  }\n\n  cleanRetrier() {\n    if (this.retrier) {\n      this.retrier.removeAllListeners();\n      this.retrier.cancel();\n      this.retrier = null;\n    }\n  }\n\n  getRetryPolicy() {\n    const clone = Object.assign({}, this.options);\n\n    if (this.newBackoff) {\n      clone.min = this.newBackoff;\n      clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;\n    } // As we're always skipping first attempt we should add one extra if limit is present\n\n\n    clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : undefined;\n    return clone;\n  }\n\n  createRetrier() {\n    this.cleanRetrier();\n    const retryPolicy = this.getRetryPolicy();\n    this.retrier = new operation_retrier_1.Retrier(retryPolicy);\n    this.retrier.once('attempt', () => {\n      this.retrier.on('attempt', () => this.emit('attempt'));\n      this.retrier.failed(new Error('Skipping first attempt'));\n    });\n    this.retrier.on('failed', err => this.emit('failed', err));\n    this.usedBackoff = this.newBackoff;\n    this.newBackoff = null;\n    this.retrier.start().catch(err => {});\n  }\n\n}\n\nexports.BackoffRetrier = BackoffRetrier;","map":null,"metadata":{},"sourceType":"script"}