{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst StateMachine = require(\"javascript-state-machine\");\n\nconst logger_1 = require(\"./logger\");\n\nconst Messages = require(\"./protocol/messages\");\n\nconst parser_1 = require(\"./parser\");\n\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nconst backoffretrier_1 = require(\"./backoffretrier\");\n\nconst DISCONNECTING_TIMEOUT = 3000; // Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\n\nfunction trampoline(f) {\n  setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nclass Request {}\n\nclass Response {}\n\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\n\nclass TwilsockChannel extends events_1.EventEmitter {\n  constructor(websocket, transport, config) {\n    super();\n    this.terminalStates = ['disconnected', 'rejected'];\n    this.lastEmittedState = undefined;\n    this.tokenExpiredSasCode = 20104;\n    this.websocket = websocket;\n    this.websocket.on('connected', () => this.fsm.socketConnected());\n    this.websocket.on('disconnected', e => this.fsm.socketClosed());\n    this.websocket.on('message', message => this.onIncomingMessage(message));\n    this.websocket.on('socketError', e => this.emit('connectionError', {\n      terminal: false,\n      message: e.message,\n      httpStatusCode: null,\n      errorCode: null\n    }));\n    this.transport = transport;\n    this.config = config;\n    this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n    this.retrier.on('attempt', () => this.retry());\n    this.retrier.on('failed', err => {\n      logger_1.log.warn(\"Retrying failed: \".concat(err.message));\n      this.disconnect();\n    });\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n      window.addEventListener('online', () => {\n        logger_1.log.debug('Browser reported connectivity state: online');\n        this.fsm.systemOnline();\n      });\n      window.addEventListener('offline', () => {\n        logger_1.log.debug('Browser reported connectivity state: online');\n        this.websocket.close();\n        this.fsm.socketClosed();\n      });\n    }\n\n    this.fsm = new StateMachine({\n      init: 'disconnected',\n      transitions: [{\n        name: 'userConnect',\n        from: ['disconnected', 'rejected'],\n        to: 'connecting'\n      }, {\n        name: 'userConnect',\n        from: ['connecting', 'connected']\n      }, {\n        name: 'userDisconnect',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected', 'waitSocketClosed', 'waitOffloadSocketClosed'],\n        to: 'disconnecting'\n      }, {\n        name: 'userRetry',\n        from: ['retrying'],\n        to: 'connecting'\n      }, {\n        name: 'socketConnected',\n        from: ['connecting'],\n        to: 'initialising'\n      }, {\n        name: 'socketClosed',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'error', 'waitOffloadSocketClosed'],\n        to: 'retrying'\n      }, {\n        name: 'socketClosed',\n        from: ['disconnecting'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['waitSocketClosed'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['rejected'],\n        to: 'rejected'\n      }, {\n        name: 'initSuccess',\n        from: ['initialising'],\n        to: 'connected'\n      }, {\n        name: 'initError',\n        from: ['initialising'],\n        to: 'error'\n      }, {\n        name: 'tokenRejected',\n        from: ['initialising', 'updating'],\n        to: 'rejected'\n      }, {\n        name: 'protocolError',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'error'\n      }, {\n        name: 'receiveClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitSocketClosed'\n      }, {\n        name: 'receiveOffload',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitOffloadSocketClosed'\n      }, {\n        name: 'unsupportedProtocol',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'receiveFatalClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'userUpdateToken',\n        from: ['disconnected', 'rejected', 'connecting', 'retrying'],\n        to: 'connecting'\n      }, {\n        name: 'userUpdateToken',\n        from: ['connected'],\n        to: 'updating'\n      }, {\n        name: 'updateSuccess',\n        from: ['updating'],\n        to: 'connected'\n      }, {\n        name: 'updateError',\n        from: ['updating'],\n        to: 'error'\n      }, {\n        name: 'userSend',\n        from: ['connected'],\n        to: 'connected'\n      }, {\n        name: 'systemOnline',\n        from: ['retrying'],\n        to: 'connecting'\n      }],\n      methods: {\n        onConnecting: () => {\n          this.setupSocket();\n          this.emit('connecting');\n        },\n        onEnterInitialising: () => {\n          this.sendInit();\n        },\n        onLeaveInitialising: () => {\n          this.cancelInit();\n        },\n        onEnterUpdating: () => {\n          this.sendUpdate();\n        },\n        onLeaveUpdating: () => {\n          this.cancelUpdate();\n        },\n        onEnterRetrying: () => {\n          this.initRetry();\n          this.emit('connecting');\n        },\n        onEnterConnected: () => {\n          this.resetBackoff();\n          this.onConnected();\n        },\n        onUserUpdateToken: () => {\n          this.resetBackoff();\n        },\n        onTokenRejected: () => {\n          this.resetBackoff();\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onUserDisconnect: () => {\n          this.closeSocket(true);\n        },\n        onEnterDisconnecting: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveDisconnecting: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitOffloadSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitOffloadSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onDisconnected: () => {\n          this.resetBackoff();\n          this.finalizeSocket();\n        },\n        onReceiveClose: (event, args) => {\n          this.onCloseReceived(args);\n        },\n        onReceiveOffload: (event, args) => {\n          logger_1.log.debug('onreceiveoffload: ', args);\n          this.modifyBackoff(args.body);\n          this.onCloseReceived(args.status);\n        },\n        onUnsupported: () => {\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onError: (lifecycle, graceful) => {\n          this.closeSocket(graceful);\n          this.finalizeSocket();\n        },\n        onEnterState: event => {\n          if (event.from !== 'none') {\n            this.changeState(event);\n          }\n        },\n        onInvalidTransition: (transition, from, to) => {\n          logger_1.log.warn('FSM: unexpected transition', from, to);\n        }\n      }\n    });\n  }\n\n  changeState(event) {\n    logger_1.log.debug(\"FSM: \".concat(event.transition, \": \").concat(event.from, \" --> \").concat(event.to));\n\n    if (this.lastEmittedState !== this.state) {\n      this.lastEmittedState = this.state;\n      this.emit('stateChanged', this.state);\n    }\n  }\n\n  resetBackoff() {\n    logger_1.log.trace('resetBackoff');\n    this.retrier.stop();\n  }\n\n  modifyBackoff(body) {\n    logger_1.log.trace('modifyBackoff', body);\n    let backoffPolicy = body ? body.backoff_policy : null;\n\n    if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n      this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n    }\n  }\n\n  startDisconnectTimer() {\n    logger_1.log.trace('startDisconnectTimer');\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n\n    this.disconnectingTimer = setTimeout(() => {\n      logger_1.log.debug('disconnecting is timed out');\n      this.closeSocket(true);\n    }, DISCONNECTING_TIMEOUT);\n  }\n\n  cancelDisconnectTimer() {\n    logger_1.log.trace('cancelDisconnectTimer');\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n  }\n\n  get isConnected() {\n    return this.state === 'connected' && this.websocket.isConnected;\n  }\n\n  get state() {\n    switch (this.fsm.state) {\n      case 'connecting':\n      case 'initialising':\n      case 'retrying':\n      case 'error':\n        return 'connecting';\n\n      case 'updating':\n      case 'connected':\n        return 'connected';\n\n      case 'rejected':\n        return 'rejected';\n\n      case 'disconnecting':\n      case 'waitSocketClosed':\n      case 'waitOffloadSocketClosed':\n        return 'disconnecting';\n\n      case 'disconnected':\n      default:\n        return 'disconnected';\n    }\n  }\n\n  initRetry() {\n    logger_1.log.debug('initRetry');\n\n    if (this.retrier.inProgress) {\n      this.retrier.attemptFailed();\n    } else {\n      this.retrier.start();\n    }\n  }\n\n  retry() {\n    if (this.fsm.state != 'connecting') {\n      logger_1.log.trace('retry');\n      this.websocket.close();\n      this.fsm.userRetry();\n    } else {\n      logger_1.log.trace('can\\t retry as already connecting');\n    }\n  }\n\n  onConnected() {\n    this.emit('connected');\n  }\n\n  finalizeSocket() {\n    logger_1.log.trace('finalizeSocket');\n    this.websocket.close();\n    this.emit('disconnected');\n\n    if (this.disconnectedPromiseResolve) {\n      this.disconnectedPromiseResolve();\n      this.disconnectedPromiseResolve = null;\n    }\n  }\n\n  setupSocket() {\n    logger_1.log.trace('setupSocket:', this.config.token);\n    this.websocket.connect();\n  }\n\n  onIncomingMessage(message) {\n    let _parser_1$Parser$pars = parser_1.Parser.parse(message),\n        method = _parser_1$Parser$pars.method,\n        header = _parser_1$Parser$pars.header,\n        payload = _parser_1$Parser$pars.payload;\n\n    if (method !== 'reply') {\n      this.confirmReceiving(header);\n    }\n\n    if (method === 'notification') {\n      this.emit('message', header.message_type, payload);\n    } else if (header.method === 'reply') {\n      this.transport.processReply({\n        id: header.id,\n        status: header.status,\n        header: header,\n        body: payload\n      });\n    } else if (header.method === 'client_update') {\n      if (header.client_update_type === 'token_about_to_expire') {\n        this.emit('tokenAboutToExpire');\n      }\n    } else if (header.method === 'close') {\n      if (header.status.code === 308) {\n        logger_1.log.debug('Connection has been offloaded');\n        this.fsm.receiveOffload({\n          status: header.status.status,\n          body: payload\n        });\n      } else if (header.status.code === 406) {\n        // Not acceptable message\n        const message = \"Server closed connection because can't parse protocol: \".concat(JSON.stringify(header.status));\n        this.emitReplyConnectionError(message, header, true);\n        logger_1.log.error(message);\n        this.fsm.receiveFatalClose();\n      } else if (header.status.code === 417) {\n        // Protocol error\n        logger_1.log.error(\"Server closed connection because can't parse client reply: \".concat(JSON.stringify(header.status)));\n        this.fsm.receiveFatalClose(header.status.status);\n      } else if (header.status.code === 410) {\n        // Expired token\n        logger_1.log.warn(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n        this.fsm.receiveClose(header.status.status);\n        this.emit('tokenExpired');\n      } else if (header.status.code === 401) {\n        // Authentication fail\n        logger_1.log.error(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n        this.fsm.receiveClose(header.status.status);\n      } else {\n        logger_1.log.warn('unexpected message: ', header.status); // Try to reconnect\n\n        this.fsm.receiveOffload({\n          status: header.status.status,\n          body: null\n        });\n      }\n    }\n  }\n\n  async sendInit() {\n    logger_1.log.trace('sendInit');\n\n    try {\n      let reply = await this.transport.sendInit();\n      this.config.updateContinuationToken(reply.continuationToken);\n      this.fsm.initSuccess(reply);\n      this.emit('initialized', reply);\n      this.emit('tokenUpdated');\n    } catch (ex) {\n      if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n        let isTerminalError = false;\n        logger_1.log.warn(\"Init rejected by server: \".concat(JSON.stringify(ex.reply.status)));\n\n        if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n          isTerminalError = true;\n          this.fsm.tokenRejected(ex.reply.status);\n\n          if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n            this.emit('tokenExpired');\n          }\n        } else if (ex.reply.status.code === 429) {\n          this.modifyBackoff(ex.reply.body);\n          this.fsm.initError(true);\n        } else if (ex.reply.status.code === 500) {\n          this.fsm.initError(false);\n        } else {\n          this.fsm.initError(true);\n        }\n\n        this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n      } else {\n        this.emit('connectionError', {\n          terminal: true,\n          message: ex.message,\n          httpStatusCode: null,\n          errorCode: null\n        });\n        this.fsm.initError(true);\n      }\n\n      this.emit('tokenUpdated', ex);\n    }\n  }\n\n  async sendUpdate() {\n    logger_1.log.trace('sendUpdate');\n    let message = new Messages.Update(this.config.token);\n\n    try {\n      let reply = await this.transport.sendWithReply(message);\n      this.fsm.updateSuccess(reply.body);\n      this.emit('tokenUpdated');\n    } catch (ex) {\n      if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n        let isTerminalError = false;\n        logger_1.log.warn(\"Token update rejected by server: \".concat(JSON.stringify(ex.reply.status)));\n\n        if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n          isTerminalError = true;\n          this.fsm.tokenRejected(ex.reply.status);\n\n          if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n            this.emit('tokenExpired');\n          }\n        } else if (ex.reply.status.code === 429) {\n          this.modifyBackoff(ex.reply.body);\n          this.fsm.updateError(ex.reply.status);\n        } else {\n          this.fsm.updateError(ex.reply.status);\n        }\n\n        this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n      } else {\n        this.emit('error', false, ex.message, null, null);\n        this.fsm.updateError(ex);\n      }\n\n      this.emit('tokenUpdated', ex);\n    }\n  }\n\n  emitReplyConnectionError(message, header, terminal) {\n    const description = header.status && header.status.description ? header.status.description : message;\n    const httpStatusCode = header.status.code;\n    const errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;\n    this.emit('connectionError', {\n      terminal: terminal,\n      message: description,\n      httpStatusCode: httpStatusCode,\n      errorCode: errorCode\n    });\n  }\n\n  cancelInit() {\n    logger_1.log.trace('cancelInit'); // TODO: implement\n  }\n\n  cancelUpdate() {\n    logger_1.log.trace('cancelUpdate'); // TODO: implement\n  }\n  /**\n   * Should be called for each message to confirm it received\n   */\n\n\n  confirmReceiving(messageHeader) {\n    logger_1.log.trace('confirmReceiving');\n\n    try {\n      this.transport.send(new Messages.Reply(messageHeader.id));\n    } catch (e) {\n      logger_1.log.debug('failed to confirm packet receiving', e);\n    }\n  }\n  /**\n   * Shutdown connection\n   */\n\n\n  closeSocket(graceful) {\n    logger_1.log.trace(\"closeSocket (graceful: \".concat(graceful, \")\"));\n\n    if (graceful && this.transport.isConnected) {\n      this.transport.sendClose();\n    }\n\n    this.websocket.close();\n    trampoline(() => this.fsm.socketClosed());\n  }\n  /**\n   * Initiate the twilsock connection\n   * If already connected, it does nothing\n   */\n\n\n  connect() {\n    logger_1.log.trace('connect');\n    this.fsm.userConnect();\n  }\n  /**\n   * Close twilsock connection\n   * If already disconnected, it does nothing\n   */\n\n\n  disconnect() {\n    logger_1.log.trace('disconnect');\n\n    if (this.fsm.is('disconnected')) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      this.disconnectedPromiseResolve = resolve;\n      this.fsm.userDisconnect();\n    });\n  }\n  /**\n   * Update fpa token for twilsock connection\n   */\n\n\n  updateToken(token) {\n    logger_1.log.trace('updateToken:', token);\n    return new Promise((resolve, reject) => {\n      this.once('tokenUpdated', e => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve();\n        }\n      });\n      this.fsm.userUpdateToken();\n    });\n  }\n\n  get isTerminalState() {\n    return this.terminalStates.indexOf(this.fsm.state) !== -1;\n  }\n\n  onCloseReceived(reason) {\n    this.websocket.close();\n  }\n\n}\n\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;","map":null,"metadata":{},"sourceType":"script"}