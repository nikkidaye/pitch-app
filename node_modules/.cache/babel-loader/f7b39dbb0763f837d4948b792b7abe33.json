{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"../logger\");\n\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\n\nconst twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\n\nconst Messages = require(\"../protocol/messages\");\n\nconst index_1 = require(\"../index\");\n\nconst REQUEST_TIMEOUT = 20000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n\nfunction isHttpReply(packet) {\n  return packet && packet.header && packet.header.http_status;\n}\n\nclass Request {}\n\nfunction parseUri(uri) {\n  const match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n\n  if (match) {\n    let uriStruct = {\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7],\n      params: null\n    };\n\n    if (uriStruct.search.length > 0) {\n      let paramsString = uriStruct.search.substring(1);\n      uriStruct.params = paramsString.split('&').map(el => el.split('=')).reduce((prev, curr) => {\n        if (!prev.hasOwnProperty(curr[0])) {\n          prev[curr[0]] = curr[1];\n        } else if (Array.isArray(prev[curr[0]])) {\n          prev[curr[0]].push(curr[1]);\n        } else {\n          prev[curr[0]] = [prev[curr[0]], curr[1]];\n        }\n\n        return prev;\n      }, {});\n    }\n\n    return uriStruct;\n  }\n\n  throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\n}\n\nfunction twilsockAddress(method, uri) {\n  const parsedUri = parseUri(uri);\n  let to = {\n    method: method,\n    host: parsedUri.host,\n    path: parsedUri.pathname\n  };\n\n  if (parsedUri.params) {\n    to.params = parsedUri.params;\n  }\n\n  return to;\n}\n\nfunction twilsockParams(method, uri, headers, body) {\n  return {\n    to: twilsockAddress(method, uri),\n    headers: headers,\n    body: body\n  };\n}\n\nclass Upstream {\n  constructor(transport, twilsock, config) {\n    this.config = config;\n    this.transport = transport;\n    this.pendingMessages = [];\n    this.twilsock = twilsock;\n  }\n\n  saveMessage(message) {\n    return new Promise((resolve, reject) => {\n      let requestDescriptor = {\n        message,\n        resolve: resolve,\n        reject: reject,\n        alreadyRejected: false,\n        timeout: setTimeout(() => {\n          logger_1.log.debug('request is timed out');\n          reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout'));\n          requestDescriptor.alreadyRejected = true;\n        }, REQUEST_TIMEOUT)\n      };\n      this.pendingMessages.push(requestDescriptor);\n    });\n  }\n\n  sendPendingMessages() {\n    while (this.pendingMessages.length) {\n      let request = this.pendingMessages[0]; // Do not send message if we've rejected its promise already\n\n      if (!request.alreadyRejected) {\n        try {\n          let message = request.message;\n          this.actualSend(message).then(response => request.resolve(response)).catch(e => request.reject(e));\n          clearTimeout(request.timeout);\n        } catch (e) {\n          logger_1.log.debug('Failed to send pending message', e);\n          break;\n        }\n      }\n\n      this.pendingMessages.splice(0, 1);\n    }\n  }\n\n  rejectPendingMessages() {\n    this.pendingMessages.forEach(message => {\n      message.reject(new index_1.TransportUnavailableError(\"Can't connect to twilsock\"));\n      clearTimeout(message.timeout);\n    });\n    this.pendingMessages.splice(0, this.pendingMessages.length);\n  }\n\n  async actualSend(message) {\n    let address = message.to;\n    let headers = message.headers;\n    let body = message.body;\n    let httpRequest = {\n      host: address.host,\n      path: address.path,\n      method: address.method,\n      params: address.params,\n      headers: headers\n    };\n    let upstreamMessage = new Messages.Message(this.config.activeGrant, headers['Content-Type'] || 'application/json', httpRequest);\n    let reply = await this.transport.sendWithReply(upstreamMessage, body);\n\n    if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {\n      throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n    }\n\n    return {\n      status: reply.header.http_status,\n      headers: reply.header.http_headers,\n      body: reply.body\n    };\n  }\n  /**\n   * Send an upstream message\n   * @param {Twilsock#Message} message Message structure with header, body and remote address\n   * @returns {Promise<Result>} Result from remote side\n   */\n\n\n  send(method, url, headers = {}, body) {\n    if (this.twilsock.isTerminalState) {\n      return Promise.reject(new index_1.TransportUnavailableError(\"Can't connect to twilsock\"));\n    }\n\n    let twilsockMessage = twilsockParams(method, url, headers, body);\n\n    if (!this.twilsock.isConnected) {\n      return this.saveMessage(twilsockMessage);\n    }\n\n    return this.actualSend(twilsockMessage);\n  }\n\n}\n\nexports.Upstream = Upstream;","map":null,"metadata":{},"sourceType":"script"}