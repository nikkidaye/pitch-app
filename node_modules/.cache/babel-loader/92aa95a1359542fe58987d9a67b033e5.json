{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst twilsock_1 = require(\"twilsock\");\n\nconst twilio_notifications_1 = require(\"twilio-notifications\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst subscriptions_1 = require(\"./subscriptions\");\n\nconst router_1 = require(\"./router\");\n\nconst network_1 = require(\"./services/network\");\n\nconst syncdocument_1 = require(\"./syncdocument\");\n\nconst synclist_1 = require(\"./synclist\");\n\nconst syncmap_1 = require(\"./syncmap\");\n\nconst clientInfo_1 = require(\"./clientInfo\");\n\nconst entitiesCache_1 = require(\"./entitiesCache\");\n\nconst storage_1 = require(\"./services/storage\");\n\nconst syncstream_1 = require(\"./streams/syncstream\");\n\nconst livequery_1 = require(\"./livequery\");\n\nconst livequery_2 = require(\"./livequery\");\n\nconst SYNC_PRODUCT_ID = 'data_sync';\n\nconst SDK_VERSION = require('../package.json').version;\n\nfunction decompose(arg) {\n  if (!arg) {\n    return {\n      mode: 'create_new'\n    };\n  } else if (typeof arg === 'string') {\n    return {\n      id: arg,\n      mode: 'open_or_create'\n    };\n  } else {\n    sanitize_1.validateOptionalTtl(arg.ttl);\n    let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\n    return Object.assign({}, arg, {\n      mode: mode\n    });\n  }\n}\n/**\n * @class Client\n * @classdesc\n * Client for the Twilio Sync service.\n * @constructor\n * @param {String} token - Twilio access token.\n * @param {Client#ClientOptions} [options] - Options to customize the Client.\n * @example\n * // Using NPM\n * var SyncClient = require('twilio-sync');\n * var syncClient = new SyncClient(token, { logLevel: 'debug' });\n *\n * // Using CDN\n * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\n *\n * @property {Client#ConnectionState} connectionState - Contains current service connection state.\n * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].\n */\n\n\nclass Client extends events_1.EventEmitter {\n  constructor(fpaToken, options = {}) {\n    super();\n\n    if (!fpaToken) {\n      throw new Error('Sync library needs a valid Twilio token to be passed');\n    }\n\n    if (options.hasOwnProperty('logLevel')) {\n      logger_1.default.setLevel(options.logLevel);\n    } else {\n      logger_1.default.setLevel('silent');\n    }\n\n    const productId = options.productId = options.productId || SYNC_PRODUCT_ID;\n    let twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);\n    twilsock.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\n    twilsock.on('tokenExpired', () => this.emit('tokenExpired'));\n    twilsock.on('connectionError', err => this.emit('connectionError', err));\n    let notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);\n    let config = new configuration_1.Configuration(options);\n    let network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);\n    let storage = new storage_1.SessionStorage(config);\n    this.localStorageId = null;\n    twilsock.connect();\n    this.services = {\n      config,\n      twilsock,\n      notifications,\n      network,\n      storage,\n      router: null,\n      subscriptions: null\n    };\n    let subscriptions = new subscriptions_1.Subscriptions(this.services);\n    let router = new router_1.Router({\n      config,\n      subscriptions,\n      notifications\n    });\n    this.services.router = router;\n    this.services.subscriptions = subscriptions;\n    this.entities = new entitiesCache_1.EntitiesCache();\n    notifications.on('connectionStateChanged', () => {\n      this.emit('connectionStateChanged', this.services.notifications.connectionState);\n    });\n  }\n  /**\n   * Current version of Sync client.\n   * @name Client#version\n   * @type String\n   * @readonly\n   */\n\n\n  static get version() {\n    return SDK_VERSION;\n  }\n\n  get connectionState() {\n    return this.services.notifications.connectionState;\n  }\n  /**\n   * Returns promise which resolves when library is correctly initialized\n   * Or throws if initialization is impossible\n   * @private\n   */\n\n\n  async ensureReady() {\n    if (!this.services.config.sessionStorageEnabled) {\n      return;\n    }\n\n    try {\n      let storageSettings = await this.services.twilsock.storageId();\n      this.services.storage.updateStorageId(storageSettings.id);\n    } catch (e) {\n      logger_1.default.warn('Failed to initialize storage', e);\n    }\n  }\n\n  storeRootInSessionCache(type, id, value) {\n    // can't store without id\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return;\n    }\n\n    let valueToStore = sanitize_1.deepClone(value);\n\n    if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {\n      valueToStore['last_event_id'] = null;\n      delete valueToStore['items'];\n    }\n\n    this.services.storage.store(type, id, valueToStore);\n  }\n\n  readRootFromSessionCache(type, id) {\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return null;\n    }\n\n    return this.services.storage.read(type, id);\n  }\n\n  async _get(baseUri, id, optimistic = false) {\n    if (!id) {\n      throw new syncerror_1.SyncError(\"Cannot get entity without id\", 404);\n    }\n\n    const uri = new uri_1.UriBuilder(baseUri).pathSegment(id).queryParam('Include', optimistic ? 'items' : undefined).build();\n    let response = await this.services.network.get(uri);\n    return response.body;\n  }\n\n  _createDocument(id, data, ttl) {\n    let requestBody = {\n      unique_name: id,\n      data: data || {}\n    };\n\n    if (typeof ttl === 'number') {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.documentsUri, requestBody).then(response => {\n      response.body.data = requestBody.data;\n      return response.body;\n    });\n  }\n\n  async _getDocument(id) {\n    return this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id);\n  }\n\n  _createList(id, purpose, context, ttl) {\n    const requestBody = {\n      unique_name: id,\n      purpose: purpose,\n      context: context\n    };\n\n    if (typeof ttl === 'number') {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);\n  }\n\n  async _getList(id) {\n    return this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id);\n  }\n\n  _createMap(id, ttl) {\n    let requestBody = {\n      unique_name: id\n    };\n\n    if (typeof ttl === 'number') {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);\n  }\n\n  async _getMap(id, optimistic = false) {\n    return this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic);\n  }\n\n  async _getStream(id) {\n    return this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false);\n  }\n\n  async _createStream(id, ttl) {\n    let requestBody = {\n      unique_name: id\n    };\n\n    if (typeof ttl === 'number') {\n      requestBody.ttl = ttl;\n    }\n\n    const response = await this.services.network.post(this.services.config.streamsUri, requestBody);\n    const streamDescriptor = response.body;\n    return streamDescriptor;\n  }\n\n  _getLiveQuery(sid) {\n    return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);\n  }\n\n  getCached(id, type) {\n    if (id) {\n      return this.entities.get(id, type) || null;\n    }\n\n    return null;\n  }\n\n  removeFromCacheAndSession(type, sid, uniqueName) {\n    this.entities.remove(sid);\n\n    if (this.services.config.sessionStorageEnabled) {\n      this.services.storage.remove(type, sid, uniqueName);\n    }\n  }\n  /**\n   * Read or create a Sync Document.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).\n   * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.document('MyDocument')\n   *   .then(function(document) {\n   *     console.log('Successfully opened a Document. SID: ' + document.sid);\n   *     document.on('updated', function(event) {\n   *       console.log('Received updated event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  async document(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let docDescriptor;\n\n    if (opts.mode === 'create_new') {\n      docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n    } else {\n      let docFromInMemoryCache = this.getCached(opts.id, syncdocument_1.SyncDocument.type);\n\n      if (docFromInMemoryCache) {\n        return new syncdocument_1.SyncDocument(docFromInMemoryCache);\n      } else {\n        try {\n          docDescriptor = await this._getDocument(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.document(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);\n    let syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncDocumentImpl = this.entities.store(syncDocumentImpl);\n    return new syncdocument_1.SyncDocument(syncDocumentImpl);\n  }\n  /**\n   * Read or create a Sync Map.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).\n   * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.map('MyMap')\n   *   .then(function(map) {\n   *     console.log('Successfully opened a Map. SID: ' + map.sid);\n   *     map.on('itemUpdated', function(event) {\n   *       console.log('Received itemUpdated event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  async map(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let mapDescriptor;\n\n    if (opts.mode === 'create_new') {\n      mapDescriptor = await this._createMap(opts.id, opts.ttl);\n    } else {\n      let mapFromInMemoryCache = this.getCached(opts.id, syncmap_1.SyncMap.type);\n\n      if (mapFromInMemoryCache) {\n        return new syncmap_1.SyncMap(mapFromInMemoryCache);\n      } else {\n        try {\n          mapDescriptor = await this._getMap(opts.id, opts.includeItems);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              mapDescriptor = await this._createMap(opts.id, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.map(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);\n    let syncMapImpl = new syncmap_1.SyncMapImpl(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncMapImpl = this.entities.store(syncMapImpl);\n    return new syncmap_1.SyncMap(syncMapImpl);\n  }\n  /**\n   * Read or create a Sync List.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).\n   * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.list('MyList')\n   *   .then(function(list) {\n   *     console.log('Successfully opened a List. SID: ' + list.sid);\n   *     list.on('itemAdded', function(event) {\n   *       console.log('Received itemAdded event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  async list(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let listDescriptor;\n\n    if (opts.mode === 'create_new') {\n      listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n    } else {\n      let listFromInMemoryCache = this.getCached(opts.id, synclist_1.SyncList.type);\n\n      if (listFromInMemoryCache) {\n        return new synclist_1.SyncList(listFromInMemoryCache);\n      } else {\n        try {\n          listDescriptor = await this._getList(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.list(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);\n    let syncListImpl = new synclist_1.SyncListImpl(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n    syncListImpl = this.entities.store(syncListImpl);\n    return new synclist_1.SyncList(syncListImpl);\n  }\n  /**\n   * Read or create a Sync Message Stream.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).\n   * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\n   * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.stream('MyStream')\n   *   .then(function(stream) {\n   *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);\n   *     stream.on('messagePublished', function(event) {\n   *       console.log('Received messagePublished event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  async stream(arg) {\n    await this.ensureReady();\n    let opts = decompose(arg);\n    let streamDescriptor;\n\n    if (opts.mode === 'create_new') {\n      streamDescriptor = await this._createStream(opts.id, opts.ttl);\n    } else {\n      let streamFromInMemoryCache = this.getCached(opts.id, syncstream_1.SyncStream.type);\n\n      if (streamFromInMemoryCache) {\n        return new syncstream_1.SyncStream(streamFromInMemoryCache);\n      } else {\n        try {\n          streamDescriptor = await this._getStream(opts.id);\n        } catch (err) {\n          if (err.status !== 404 || opts.mode === 'open_existing') {\n            throw err;\n          } else {\n            try {\n              streamDescriptor = await this._createStream(opts.id, opts.ttl);\n            } catch (err) {\n              if (err.status === 409) {\n                return this.stream(arg);\n              } else {\n                throw err;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);\n\n    const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n\n    let syncStreamImpl = new syncstream_1.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);\n    syncStreamImpl = this.entities.store(syncStreamImpl);\n    return new syncstream_1.SyncStream(syncStreamImpl);\n  }\n  /**\n   * Gracefully shutdown the libray\n   * Currently it is not properly implemented and being used only in tests\n   * But should be made a part of public API\n   * @private\n   */\n\n\n  async shutdown() {\n    await this.services.subscriptions.shutdown();\n    await this.services.twilsock.disconnect();\n  }\n  /**\n   * Set new authentication token.\n   * @param {String} token New token to set.\n   * @return {Promise<void>}\n   * @public\n   */\n\n\n  updateToken(token) {\n    if (!token) {\n      return Promise.reject(new Error('A valid Twilio token should be provided'));\n    }\n\n    return this.services.twilsock.updateToken(token);\n  }\n  /**\n   * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\n   * result set is updated whenever new (or updated) records match the given expression. Updated results\n   * are presented row-by-row according to the lifetime of the returned LiveQuery object.\n   *\n   * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n   * @param queryExpression {String} A query expression to be executed against the given data index.\n   * Please review <a href=\"https://www.twilio.com/docs/sync/live-query\" target=\"_blank\">Live Query Language</a>\n   * page for Sync Client limits and full list of operators currently supported in query expressions.\n   *\n   * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.\n   * @public\n   * @example\n   * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\n   *     .then(function(args) {\n   *        console.log('Subscribed to live data updates for worker Bob');\n   *        let items = args.getItems();\n   *        Object.entries(items).forEach(([key, value]) => {\n   *          console.log('Search result item key: ' + key);\n   *          console.log('Search result item value: ' + value);\n   *        });\n   *     })\n   *     .catch(function(err) {\n   *        console.log('Error when subscribing to live updates for worker Bob', err);\n   *     });\n   */\n\n\n  async liveQuery(indexName, queryExpression) {\n    await this.ensureReady();\n\n    if (!indexName || typeof indexName !== 'string') {\n      throw new Error('Index name must contain a non-empty string value');\n    }\n\n    let queryUri = new uri_1.UriBuilder(this.services.config.insightsUri).pathSegment(indexName).pathSegment('Items').build(); // send query to CDS to get server-generated sid and item list\n\n    let response = await livequery_2.queryItems({\n      network: this.services.network,\n      uri: queryUri,\n      queryString: queryExpression\n    });\n    let liveQueryImpl = this.getCached(response.query_id, livequery_1.LiveQuery.type);\n\n    if (!liveQueryImpl) {\n      let descriptor = this._getLiveQuery(response.query_id);\n\n      if (!descriptor) {\n        descriptor = {\n          indexName,\n          queryExpression,\n          sid: response.query_id,\n          queryUri\n        };\n      }\n\n      const liveQueryRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n\n      liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);\n    }\n\n    this.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\n    liveQueryImpl = this.entities.store(liveQueryImpl);\n    return new livequery_1.LiveQuery(liveQueryImpl);\n  }\n  /**\n   * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\n   * against the target index.\n   *\n   * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n   * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.\n   * @public\n   * @example\n   * syncClient.instantQuery('tr-worker')\n   *    .then(function(q) {\n   *        q.on('searchResult', function(items) {\n   *          Object.entries(items).forEach(([key, value]) => {\n   *             console.log('Search result item key: ' + key);\n   *             console.log('Search result item value: ' + value);\n   *          });\n   *       });\n   *    });\n   */\n\n\n  async instantQuery(indexName) {\n    await this.ensureReady();\n\n    let liveQueryCreator = (indexName, queryExpression) => {\n      return this.liveQuery(indexName, queryExpression);\n    };\n\n    const search = new livequery_1.InstantQuery({\n      indexName,\n      network: this.services.network,\n      insightsUri: this.services.config.insightsUri,\n      liveQueryCreator\n    });\n    return search;\n  }\n\n}\n\nexports.Client = Client;\nexports.SyncClient = Client;\nexports.default = Client;\n/**\n * Indicates current state of connection between the client and Sync service.\n * <p>Valid options are as follows:\n * <li>'connecting' - client is offline and connection attempt is in process.\n * <li>'connected' - client is online and ready.\n * <li>'disconnecting' - client is going offline as disconnection is in process.\n * <li>'disconnected' - client is offline and no connection attempt is in process.\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\n * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState\n */\n\n/**\n * These options can be passed to Client constructor.\n * @typedef {Object} Client#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].\n */\n\n/**\n * Fired when connection state has been changed.\n * @param {Client#ConnectionState} connectionState Contains current service connection state.\n * @event Client#connectionStateChanged\n * @example\n * syncClient.on('connectionStateChanged', function(newState) {\n *   console.log('Received new connection state: ' + newState);\n * });\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @property {Object} error - connection error details\n * @property {Boolean} error.terminal - twilsock will stop connection attempts\n * @property {String} error.message - root cause\n * @property {Number} [error.httpStatusCode] - http status code if available\n * @property {Number} [error.errorCode] - Twilio public error code if available\n * @event Client#connectionError\n * @example\n * syncClient.on('connectionError', function(connectionError) {\n *   console.log('Connection was interrupted: ' + connectionError.message +\n *     ' (isTerminal: ' + connectionError.terminal')');\n * });\n */\n\n/**\n * Options for opening a Sync Object.\n * @typedef {Object} Client#OpenOptions\n * @property {String} [id] Sync object SID or unique name.\n * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:\n * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.\n * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.\n * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.\n * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.\n * @property {Object} [value={ }] - The initial value for the Sync Document (only applicable to Documents).\n * @example <caption>The following example is applicable to all Sync objects\n * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>\n * // Attempts to open an existing Document with unique name 'MyDocument'\n * // If no such Document exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'open_existing'\n *   })\n *   .then(...)\n *   .catch(...);\n *\n * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial value { name: 'John Smith' }\n * // If such a Document already exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'create_new',\n *     ttl: 86400\n *     value: { name: 'John Smith' } // the `value` property is only applicable for Documents\n *   })\n *   .then(...)\n *   .catch(...);\n */\n\n/**\n * Fired when the access token is about to expire and needs to be updated.\n * The trigger takes place three minutes before the JWT access token expiry.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenAboutToExpire\n * @type {void}\n * @example <caption>The following example illustrates access token refresh</caption>\n * syncClient.on('tokenAboutToExpire', function() {\n *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\n *   var token = '<your-access-token-here>';\n *   syncClient.updateToken(token);\n * });\n */\n\n/**\n * Fired when the access token is expired.\n * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenExpired\n * @type {void}\n */","map":null,"metadata":{},"sourceType":"script"}