{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mapitem_1 = require(\"./mapitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncMapImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n\n    if (descriptor.items) {\n      descriptor.items.forEach(itemDescriptor => {\n        itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n        this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n      });\n    }\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'map';\n  }\n\n  get type() {\n    return 'map';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  async set(key, value, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(key, input, input => this._putItemUnconditionally(key, value, input.ttl));\n  }\n\n  async get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    } else {\n      return this._getItemFromServer(key);\n    }\n  }\n\n  async _getItemFromServer(key) {\n    let result = await this.queryItems({\n      key: key\n    });\n\n    if (result.items.length < 1) {\n      throw new syncerror_1.SyncError(\"No item with key \".concat(key, \" found\"), 404, 54201);\n    } else {\n      return result.items[0];\n    }\n  }\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(key, input, input => this._putItemWithIfMatch(key, mutator, input.ttl));\n  }\n\n  async update(key, obj, itemMetadataUpdates) {\n    return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n  }\n\n  async _putItemUnconditionally(key, data, ttl) {\n    const result = await this._putItemToServer(key, data, undefined, ttl);\n    const item = result.item;\n\n    this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n    return this.cache.get(item.key);\n  }\n\n  async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n    const currentItem = await this.get(key).catch(error => {\n      if (error.status === 404) {\n        // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n        return new mapitem_1.MapItem({\n          key: key,\n          data: {},\n          last_event_id: -1,\n          revision: '-1',\n          url: null,\n          date_updated: null,\n          date_expires: null\n        });\n      } else {\n        throw error;\n      }\n    });\n    let data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n\n    if (data) {\n      let ifMatch = currentItem.revision;\n\n      try {\n        const result = await this._putItemToServer(key, data, ifMatch, ttl);\n        const item = result.item;\n\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n        return this.cache.get(item.key);\n      } catch (error) {\n        if (error.status === 412) {\n          await this._getItemFromServer(key);\n          return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return currentItem;\n    }\n  }\n\n  async _putItemToServer(key, data, ifMatch, ttl) {\n    const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n    const requestBody = {\n      data\n    };\n\n    if (typeof ttl === 'number') {\n      requestBody.ttl = ttl;\n    }\n\n    try {\n      const response = await this.services.network.put(url, requestBody, ifMatch);\n      const mapItemDescriptor = response.body;\n      mapItemDescriptor.data = data; // The server does not return the data in the response\n\n      mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n      const added = response.status.code === 201;\n      return {\n        added,\n        item: mapItemDescriptor\n      };\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async remove(key) {\n    if (typeof key === 'undefined') {\n      throw new Error('Key argument is invalid');\n    }\n\n    let item = await this.get(key);\n    let response = await this.services.network.delete(item.uri);\n\n    this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n  }\n  /**\n   * @private\n   */\n\n\n  async queryItems(args) {\n    args = args || {};\n    const uri = new uri_1.UriBuilder(this.links.items).queryParam('From', args.from).queryParam('PageSize', args.limit).queryParam('Key', args.key).queryParam('PageToken', args.pageToken).queryParam('Order', args.order).build();\n    let response = await this.services.network.get(uri);\n    let items = response.body.items.map(el => {\n      el.date_updated = new Date(el.date_updated);\n      let itemInCache = this.cache.get(el.key);\n\n      if (itemInCache) {\n        this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n      } else {\n        this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n      }\n\n      return this.cache.get(el.key);\n    });\n    const meta = response.body.meta;\n    return new paginator_1.Paginator(items, pageToken => this.queryItems({\n      pageToken\n    }), meta.previous_token, meta.next_token);\n  }\n\n  async getItems(args) {\n    args = args || {};\n    sanitize_1.validatePageSize(args.pageSize);\n    args.limit = args.pageSize || args.limit || 50;\n    args.order = args.order || 'asc';\n    return this.queryItems(args);\n  }\n  /**\n   * Enumerate all items in this Map.\n   * This always triggers server interaction when being called for the first time on a Map; this may be latent.\n   * This method not supported now and not meant to be used externally.\n   * @param {Function} handler Function to handle each argument.\n   * @private\n   */\n\n\n  forEach(handler) {\n    return new Promise((resolve, reject) => {\n      function processPage(page) {\n        page.items.forEach(x => handler(x));\n\n        if (page.hasNextPage) {\n          page.nextPage().then(processPage).catch(reject);\n        } else {\n          resolve();\n        }\n      }\n\n      this.queryItems().then(processPage).catch(reject);\n    });\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\n   * Handle update from the server\n   * @private\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'map_item_added':\n      case 'map_item_updated':\n        {\n          this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n          update.type === 'map_item_added', true);\n        }\n        break;\n\n      case 'map_item_removed':\n        {\n          this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'map_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.map_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(key, lastEventId)) {\n      logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    } else {\n      this._updateRootDateUpdated(dateUpdated);\n\n      let item = this.cache.get(key);\n\n      if (!item) {\n        item = new mapitem_1.MapItem({\n          key: key,\n          url,\n          last_event_id: lastEventId,\n          revision,\n          data: value,\n          date_updated: dateUpdated,\n          date_expires: dateExpires\n        });\n        this.cache.store(key, item, lastEventId);\n        this.emitItemMutationEvent(item, remote, added);\n      } else if (item.lastEventId < lastEventId) {\n        item.update(lastEventId, revision, value, dateUpdated);\n\n        if (dateExpires !== undefined) {\n          item.updateDateExpires(dateExpires);\n        }\n\n        this.emitItemMutationEvent(item, remote, false);\n      }\n    }\n  }\n\n  emitItemMutationEvent(item, remote, added) {\n    let eventName = added ? 'itemAdded' : 'itemUpdated';\n    this.broadcastEventToListeners(eventName, {\n      item: item,\n      isLocal: !remote\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(key, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      key: key,\n      isLocal: !remote,\n      value: oldData\n    });\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async setItemTtl(key, ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    let existingItem = await this.get(key);\n    const requestBody = {\n      ttl\n    };\n    const response = await this.services.network.post(existingItem.uri, requestBody);\n    existingItem.updateDateExpires(response.body.date_expires);\n  }\n\n  async removeMap() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n\n}\n\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\n\nclass SyncMap extends closeable_1.Closeable {\n  // private props\n  get uri() {\n    return this.syncMapImpl.uri;\n  }\n\n  get links() {\n    return this.syncMapImpl.links;\n  }\n\n  get revision() {\n    return this.syncMapImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncMapImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncMapImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncMapImpl.type;\n  }\n\n  get type() {\n    return SyncMapImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncMapImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncMapImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncMapImpl.dateUpdated;\n  }\n\n  constructor(syncMapImpl) {\n    super();\n    this.syncMapImpl = syncMapImpl;\n    this.syncMapImpl.attach(this);\n  }\n  /**\n   * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\n   * @param {String} key Unique item identifier.\n   * @param {Object} value Value to be set.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\n   * @public\n   * @example\n   * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item set() successful, item value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item set() failed', error);\n   *   });\n   */\n\n\n  async set(key, value, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.set(key, value, itemMetadataUpdates);\n  }\n  /**\n   * Retrieve an item by key.\n   * @param {String} key Identifies the desired item.\n   * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n   * This promise will be rejected if item was not found.\n   * @public\n   * @example\n   * map.get('myKey')\n   *   .then(function(item) {\n   *     console.log('Map Item get() successful, item value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item get() failed', error);\n   *   });\n   */\n\n\n  async get(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.get(key);\n  }\n  /**\n   * Schedules a modification to this Map Item that will apply a mutation function.\n   * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\n   * @param {String} key Selects the map item to be mutated.\n   * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\n   * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n   * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n   * by this function.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n   * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item mutate() successful, new value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item mutate() failed', error);\n   *   });\n   */\n\n\n  async mutate(key, mutator, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n  }\n  /**\n   * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n   * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n   * into it.\n   * This is equivalent to\n   * <pre>\n   * map.mutate('myKey', function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {String} key Selects the map item to update.\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n   * @public\n   * @example\n   * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\n   * map.update('myKey', { age: 34 }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     // Now the Map Item value is { name: 'John Smith', age: 34 }\n   *     console.log('Map Item update() successful, new value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item update() failed', error);\n   *   });\n   */\n\n\n  async update(key, obj, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n  }\n  /**\n   * Delete an item, given its key.\n   * @param {String} key Selects the item to delete.\n   * @returns {Promise<void>} A promise to remove an item.\n   * The promise will be rejected if 'key' is undefined or an item was not found.\n   * @public\n   * @example\n   * map.remove('myKey')\n   *   .then(function() {\n   *     console.log('Map Item remove() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item remove() failed', error);\n   *   });\n   */\n\n\n  async remove(key) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.remove(key);\n  }\n  /**\n   * Get a complete list of items from the map.\n   * @param {Object} [args] Arguments for query.\n   * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\n   * @param {Number} [args.pageSize=50] Result page size.\n   * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\n   * @return {Promise<Paginator<MapItem>>}\n   * @public\n   * @example\n   * var pageHandler = function(paginator) {\n   *   paginator.items.forEach(function(item) {\n   *     console.log('Item ' + item.key + ': ', item.value);\n   *   });\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n   *                                : null;\n   * };\n   * map.getItems({ from: 'myKey', order: 'asc' })\n   *   .then(pageHandler)\n   *   .catch(function(error) {\n   *     console.error('Map getItems() failed', error);\n   *   });\n   */\n\n\n  async getItems(args) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.getItems(args);\n  }\n  /**\n   * Enumerate all items in this Map.\n   * This always triggers server interaction when being called for the first time on a Map; this may be latent.\n   * This method not supported now and not meant to be used externally.\n   * @param {Function} handler Function to handle each argument.\n   * @private\n   */\n\n\n  forEach(handler) {\n    this.ensureNotClosed();\n    this.syncMapImpl.forEach(handler);\n  }\n  /**\n   * Update the time-to-live of the map.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Map setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setTtl(ttl);\n  }\n  /**\n   * Update the time-to-live of a map item.\n   * @param {Number} key Item key.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setItemTtl('myKey', 86400)\n   *   .then(function() {\n   *     console.log('Map setItemTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setItemTtl() failed', error);\n   *   });\n   */\n\n\n  async setItemTtl(key, ttl) {\n    this.ensureNotClosed();\n    return this.syncMapImpl.setItemTtl(key, ttl);\n  }\n  /**\n   * Delete this map. It will be impossible to restore it.\n   * @return {Promise<void>} A promise that resolves when the map has been deleted.\n   * @public\n   * @example\n   * map.removeMap()\n   *   .then(function() {\n   *     console.log('Map removeMap() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map removeMap() failed', error);\n   *   });\n   */\n\n\n  async removeMap() {\n    this.ensureNotClosed();\n    await this.syncMapImpl.removeMap();\n  }\n  /**\n   * Conclude work with the map instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this map will continue operating and receiving events normally.\n   * @public\n   * @example\n   * map.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncMapImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {String} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":null,"metadata":{},"sourceType":"script"}