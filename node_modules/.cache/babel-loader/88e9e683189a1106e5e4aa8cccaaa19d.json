{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst events_1 = require(\"events\");\n\nconst entity_1 = require(\"./entity\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass InsightsItem {}\n\nexports.InsightsItem = InsightsItem;\n\nclass LiveQueryImpl extends entity_1.SyncEntity {\n  constructor(descriptor, services, removalHandler, items) {\n    super(services, removalHandler);\n    this.descriptor = descriptor;\n    this.items = handleItems(items);\n  } // public\n\n\n  get sid() {\n    return this.descriptor.sid;\n  } // private extension of SyncEntity\n\n\n  get uniqueName() {\n    return null;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  }\n\n  static get type() {\n    return 'live_query';\n  }\n\n  get lastEventId() {\n    return null;\n  }\n\n  get indexName() {\n    return this.descriptor.indexName;\n  }\n\n  get queryString() {\n    return this.descriptor.queryExpression;\n  } // custom private props\n\n\n  get queryUri() {\n    return this.descriptor.queryUri;\n  }\n\n  get liveQueryDescriptor() {\n    return this.descriptor;\n  }\n\n  get network() {\n    return this.services.network;\n  } // dummy stub from iface\n\n\n  onRemoved() {}\n\n  getItems() {\n    const dataByKey = {};\n\n    if (this.items) {\n      Object.keys(this.items).map((key, index) => {\n        dataByKey[key] = this.items[key].value;\n      });\n    }\n\n    return dataByKey;\n  }\n  /**\n   * @private\n   */\n\n\n  _update(message) {\n    const key = message.item_key;\n    const revision = message.item_revision;\n\n    switch (message.type) {\n      case 'live_query_item_updated':\n        const existingItem = this.items[key];\n\n        if (!existingItem || revision > existingItem.revision) {\n          const newItem = {\n            key,\n            revision,\n            value: message.item_data\n          };\n          this.items[key] = newItem;\n          this.broadcastEventToListeners('itemUpdated', newItem);\n        }\n\n        break;\n\n      case 'live_query_item_removed':\n        delete this.items[key];\n        this.broadcastEventToListeners('itemRemoved', {\n          key\n        });\n        break;\n    }\n  }\n\n}\n\nexports.LiveQueryImpl = LiveQueryImpl;\n\nasync function queryItems(params) {\n  let network = params.network,\n      queryString = params.queryString,\n      uri = params.uri;\n\n  if (queryString == null) {\n    // should not be null or undefined\n    throw new syncerror_1.SyncError(\"Invalid query\", 400, 54507);\n  }\n\n  const liveQueryRequestBody = {\n    query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n\n  };\n  let response = await network.post(uri, liveQueryRequestBody, undefined, true);\n  return response.body;\n}\n\nexports.queryItems = queryItems;\n\nfunction handleItems(items) {\n  if (items) {\n    return items.reduce((mapAcc, item) => {\n      mapAcc[item.key] = {\n        key: item.key,\n        value: item.data,\n        revision: item.revision\n      };\n      return mapAcc;\n    }, {});\n  }\n}\n/**\n * @class\n * @alias LiveQuery\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\n *     subsequently receives pushed updates whenever new (or updated) records would match the\n *     given expression. Updated results are presented row-by-row until this query is explicitly\n *     closed.\n *\n *     Use the {@link Client#liveQuery} method to create a live query.\n *\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\n *\n * @fires LiveQuery#itemUpdated\n * @fires LiveQuery#itemRemoved\n */\n\n\nclass LiveQuery extends closeable_1.default {\n  static get type() {\n    return LiveQueryImpl.type;\n  }\n\n  get type() {\n    return LiveQueryImpl.type;\n  } // public\n\n\n  get sid() {\n    return this.liveQueryImpl.sid;\n  }\n  /**\n   * @private\n   */\n\n\n  constructor(liveQueryImpl) {\n    super();\n    this.liveQueryImpl = liveQueryImpl;\n    this.liveQueryImpl.attach(this);\n  }\n  /**\n   * Closes this query instance and unsubscribes from further service events.\n   * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n   * @public\n   */\n\n\n  close() {\n    super.close();\n    this.liveQueryImpl.detach(this.listenerUuid);\n  }\n  /**\n   * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\n   * @public\n   */\n\n\n  getItems() {\n    this.ensureNotClosed();\n    return this.liveQueryImpl.getItems();\n  }\n\n}\n\nexports.LiveQuery = LiveQuery;\n/**\n * @class\n * @alias InstantQuery\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link Client#instantQuery} method to create an Instant Query.\n *\n * @fires InstantQuery#searchResult\n */\n\nclass InstantQuery extends events_1.EventEmitter {\n  /**\n   * @private\n   */\n  constructor(params) {\n    super();\n    this.queryExpression = null;\n    Object.assign(this, params);\n    this.updateIndexName(params.indexName);\n  } // private props\n\n\n  static get type() {\n    return 'instant_query';\n  }\n\n  get type() {\n    return InstantQuery.type;\n  }\n  /**\n   * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\n   * event.\n   * @param {String} queryExpression A query expression to be executed against the given data index. For more information\n   * on the syntax read {@link Client#liveQuery}.\n   * @returns {Promise<void>} A promise that resolves when query result has been received.\n   * @public\n   */\n\n\n  async search(queryExpression) {\n    return queryItems({\n      network: this.network,\n      uri: this.queryUri,\n      queryString: queryExpression\n    }).then(response => {\n      this.queryExpression = queryExpression;\n      this.items = handleItems(response.items);\n      this.emit('searchResult', this.getItems());\n    }).catch(err => {\n      logger_1.default.error(\"Error '\".concat(err.message, \"' while executing query '\").concat(queryExpression, \"'\"));\n      this.queryExpression = null;\n      this.items = null;\n      throw err;\n    });\n  }\n  /**\n   * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n   * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\n   * while current object can be still used to execute repetitive searches.\n   * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\n   * @public\n   */\n\n\n  async subscribe() {\n    if (this.queryExpression == null) {\n      // should not be null or undefined\n      return Promise.reject(new syncerror_1.SyncError(\"Invalid query\", 400, 54507));\n    }\n\n    return this.liveQueryCreator(this.indexName, this.queryExpression);\n  }\n  /**\n   * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\n   * @public\n   */\n\n\n  getItems() {\n    const dataByKey = {};\n\n    if (this.items) {\n      Object.keys(this.items).map((key, index) => {\n        dataByKey[key] = this.items[key].value;\n      });\n    }\n\n    return dataByKey;\n  }\n  /**\n   * Set new index name\n   * @param {String} indexName New index name to set\n   * @returns void\n   * @public\n   */\n\n\n  updateIndexName(indexName) {\n    if (!indexName || typeof indexName !== 'string') {\n      throw new Error('Index name must contain a non-empty string value');\n    }\n\n    this.indexName = indexName;\n    this.queryUri = this.generateQueryUri(this.indexName);\n  }\n\n  generateQueryUri(indexName) {\n    return new uri_1.UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();\n  }\n\n}\n\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\n * @class InsightsItem\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\n * @property {String} key The identifier that maps to this item within the search result.\n * @property {Object} value The contents of the item.\n */\n\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\n * {@link InsightsItem}-s.\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\n */\n\n/**\n * Fired when an item has been added or updated.\n * @event LiveQuery#itemUpdated\n * @param {InsightsItem} item Updated item.\n * @example\n * liveQuery.on('itemUpdated', function(item) {\n *   console.log('Item ' + item.key + ' was updated');\n *   console.log('Item value: ', item.value);\n * });\n */\n\n/**\n * Fired when an existing item has been removed.\n * @event LiveQuery#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @example\n * liveQuery.on('itemRemoved', function(args) {\n *   console.log('Item ' + args.key + ' was removed');\n * });\n */\n\n/**\n * Fired when a search result is ready.\n * @event InstantQuery#searchResult\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\n * @example\n * instantQuery.on('searchResult', function(items) {\n *    Object.entries(items).forEach(([key, value]) => {\n *      console.log('Search result item key: ' + key);\n *      console.log('Search result item value: ' + value);\n *    });\n * });\n */","map":null,"metadata":{},"sourceType":"script"}