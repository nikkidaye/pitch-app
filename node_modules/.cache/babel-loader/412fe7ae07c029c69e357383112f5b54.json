{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst twilsock_1 = require(\"twilsock\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst registrar_1 = require(\"./registrar\");\n\nconst logger_1 = require(\"./logger\");\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n */\n\n\nclass Client extends events_1.EventEmitter {\n  constructor(token, options = {}) {\n    super();\n\n    if (!token || token.length === 0) {\n      throw new Error('Token is required for Notifications client');\n    }\n\n    options.logLevel = options.logLevel || 'error';\n    logger_1.log.setLevel(options.logLevel);\n    const minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\n    const productId = options.productId || 'notifications';\n    options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\n    options.transport = options.transport || options.twilsockClient;\n    this.services = {\n      twilsock: options.twilsockClient,\n      transport: options.transport,\n      config: new configuration_1.Configuration(null, options)\n    };\n    this.registrar = new registrar_1.Registrar(productId, this.services.transport, this.services.twilsock, this.services.config);\n    this.reliableTransportState = {\n      overall: false,\n      transport: false,\n      registration: false,\n      lastEmitted: null\n    };\n\n    this._onTransportStateChange(this.services.twilsock.isConnected);\n\n    this.registrar.on('transportReady', state => {\n      this._onRegistrationStateChange(state ? 'registered' : '');\n    });\n    this.registrar.on('stateChanged', state => {\n      this._onRegistrationStateChange(state);\n    });\n    this.registrar.on('needReliableTransport', this._onNeedReliableTransport.bind(this));\n    this.services.twilsock.on('message', (type, message) => this._routeMessage(type, message));\n    this.services.twilsock.on('connected', notificationId => {\n      this._onTransportStateChange(true);\n\n      this.registrar.setNotificationId('twilsock', notificationId);\n    });\n    this.services.twilsock.on('disconnected', () => {\n      this._onTransportStateChange(false);\n    });\n    this.services.config.updateToken(token);\n    this.registrar.updateToken(token);\n  }\n\n  get connectionState() {\n    if (this.services.twilsock.state === 'disconnected') {\n      return 'disconnected';\n    } else if (this.services.twilsock.state === 'disconnecting') {\n      return 'disconnecting';\n    } else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\n      return 'connected';\n    } else if (this.services.twilsock.state === 'rejected') {\n      return 'denied';\n    }\n\n    return 'connecting';\n  }\n  /**\n   * Routes messages to the external subscribers\n   * @private\n   */\n\n\n  _routeMessage(type, message) {\n    logger_1.log.trace('Message arrived: ', type, message);\n    this.emit('message', type, message);\n  }\n\n  _onNeedReliableTransport(isNeeded) {\n    if (isNeeded) {\n      this.services.twilsock.connect();\n    } else {\n      this.services.twilsock.disconnect();\n    }\n  }\n\n  _onRegistrationStateChange(state) {\n    this.reliableTransportState.registration = state === 'registered';\n\n    this._updateTransportState();\n  }\n\n  _onTransportStateChange(connected) {\n    this.reliableTransportState.transport = connected;\n\n    this._updateTransportState();\n  }\n\n  _updateTransportState() {\n    const overallState = this.reliableTransportState.transport && this.reliableTransportState.registration;\n\n    if (this.reliableTransportState.overall !== overallState) {\n      this.reliableTransportState.overall = overallState;\n      logger_1.log.info('Transport ready:', overallState);\n      this.emit('transportReady', overallState);\n    }\n\n    if (this.reliableTransportState.lastEmitted !== this.connectionState) {\n      this.reliableTransportState.lastEmitted = this.connectionState;\n      this.emit('connectionStateChanged', this.connectionState);\n    }\n  }\n  /**\n   * Adds the subscription for the given message type\n   * @param {string} messageType The type of message that you want to receive\n   * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n   */\n\n\n  subscribe(messageType, channelType = 'twilsock') {\n    logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\n    return this.registrar.subscribe(messageType, channelType);\n  }\n  /**\n   * Remove the subscription for the particular message type\n   * @param {string} messageType The type of message that you don't want to receive anymore\n   * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n   */\n\n\n  unsubscribe(messageType, channelType = 'twilsock') {\n    logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\n    return this.registrar.unsubscribe(messageType, channelType);\n  }\n  /**\n   * Handle incoming push notification.\n   * Client application should call this method when it receives push notifications and pass the received data\n   * @param {Object} message push message\n   * @return {PushNotification}\n   */\n\n\n  handlePushNotification(message) {\n    return {\n      messageType: message.twi_message_type,\n      payload: message.payload\n    };\n  }\n  /**\n   * Set APN/GCM/FCM token to enable application register for a push messages\n   * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\n   */\n\n\n  setPushRegistrationId(registrationId, channelType) {\n    logger_1.log.trace('Set push registration id', registrationId, channelType);\n    this.registrar.setNotificationId(channelType, registrationId);\n  }\n  /**\n   * Updates auth token for registration\n   * @param {string} token Authentication token for registrations\n   */\n\n\n  async updateToken(token) {\n    logger_1.log.info('authTokenUpdated');\n\n    if (this.services.config.token === token) {\n      return;\n    }\n\n    await this.services.twilsock.updateToken(token);\n    this.services.config.updateToken(token);\n    this.registrar.updateToken(token);\n  }\n\n}\n\nexports.Client = Client;\n/**\n * Fired when new message arrived.\n * @param {Object} message`\n * @event Client#message\n */\n\n/**\n * Fired when transport state has changed\n * @param {boolean} transport state\n * @event Client#transportReady\n */\n\n/**\n * Fired when transport state has been changed\n * @param {string} transport state\n * @event Client#connectionStateChanged\n */\n\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */","map":null,"metadata":{},"sourceType":"script"}