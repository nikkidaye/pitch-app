{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst listitem_1 = require(\"./listitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncListImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'list';\n  }\n\n  get type() {\n    return 'list';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  async _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {\n    let requestBody = {\n      data\n    };\n\n    if (typeof ttl === 'number') {\n      requestBody.ttl = ttl;\n    }\n\n    let response = await this.services.network.post(url, requestBody, ifMatch);\n    response.body.data = data;\n    response.body.date_updated = new Date(response.body.date_updated);\n    return response.body;\n  }\n\n  async push(value, itemMetadata) {\n    let ttl = (itemMetadata || {}).ttl;\n    sanitize_1.validateOptionalTtl(ttl);\n    let item = await this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);\n    let index = Number(item.index);\n\n    this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);\n\n    return this.cache.get(index);\n  }\n\n  async set(index, value, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(index, input, input => this._updateItemUnconditionally(index, value, input.ttl));\n  }\n\n  async _updateItemUnconditionally(index, data, ttl) {\n    let existingItem = await this.get(index);\n    const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);\n\n    this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n    return this.cache.get(index);\n  }\n\n  async _updateItemWithIfMatch(index, mutatorFunction, ttl) {\n    const existingItem = await this.get(index);\n    const data = mutatorFunction(sanitize_1.deepClone(existingItem.value));\n\n    if (data) {\n      const ifMatch = existingItem.revision;\n\n      try {\n        const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);\n\n        this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n        return this.cache.get(index);\n      } catch (error) {\n        if (error.status === 412) {\n          await this._getItemFromServer(index);\n          return this._updateItemWithIfMatch(index, mutatorFunction, ttl);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return existingItem;\n    }\n  }\n\n  async mutate(index, mutator, itemMetadataUpdates) {\n    const input = itemMetadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(index, input, input => this._updateItemWithIfMatch(index, mutator, input.ttl));\n  }\n\n  async update(index, obj, itemMetadataUpdates) {\n    return this.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates);\n  }\n\n  async remove(index) {\n    let item = await this.get(index);\n    let response = await this.services.network.delete(item.uri);\n\n    this._handleItemRemoved(index, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n  }\n\n  async get(index) {\n    let cachedItem = this.cache.get(index);\n\n    if (cachedItem) {\n      return cachedItem;\n    } else {\n      return this._getItemFromServer(index);\n    }\n  }\n\n  async _getItemFromServer(index) {\n    let result = await this.queryItems({\n      index\n    });\n\n    if (result.items.length < 1) {\n      throw new syncerror_1.SyncError(\"No item with index \".concat(index, \" found\"), 404, 54151);\n    } else {\n      return result.items[0];\n    }\n  }\n  /**\n   * Query items from the List\n   * @private\n   */\n\n\n  async queryItems(arg) {\n    arg = arg || {};\n    const url = new uri_1.UriBuilder(this.links.items).queryParam('From', arg.from).queryParam('PageSize', arg.limit).queryParam('Index', arg.index).queryParam('PageToken', arg.pageToken).queryParam('Order', arg.order).build();\n    let response = await this.services.network.get(url);\n    let items = response.body.items.map(el => {\n      el.date_updated = new Date(el.date_updated);\n      let itemInCache = this.cache.get(el.index);\n\n      if (itemInCache) {\n        this._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n      } else {\n        this.cache.store(Number(el.index), new listitem_1.ListItem({\n          index: Number(el.index),\n          uri: el.url,\n          revision: el.revision,\n          lastEventId: el.last_event_id,\n          dateUpdated: el.date_updated,\n          dateExpires: el.date_expires,\n          value: el.data\n        }), el.last_event_id);\n      }\n\n      return this.cache.get(el.index);\n    });\n    let meta = response.body.meta;\n    return new paginator_1.Paginator(items, pageToken => this.queryItems({\n      pageToken\n    }), meta.previous_token, meta.next_token);\n  }\n\n  async getItems(args) {\n    args = args || {};\n    sanitize_1.validatePageSize(args.pageSize);\n    args.limit = args.pageSize || args.limit || 50;\n    args.order = args.order || 'asc';\n    return this.queryItems(args);\n  }\n  /**\n   * @return {Promise<Object>} Context of List\n   * @private\n   */\n\n\n  async getContext() {\n    if (!this.context) {\n      let response = await this.services.network.get(this.links.context); // store fetched context if we have't received any newer update\n\n      this._updateContextIfRequired(response.body.data, response.body.last_event_id);\n    }\n\n    return this.context;\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n\n    try {\n      const requestBody = {\n        ttl\n      };\n      const response = await this.services.network.post(this.uri, requestBody);\n      this.descriptor.date_expires = response.body.date_expires;\n    } catch (error) {\n      if (error.status === 404) {\n        this.onRemoved(false);\n      }\n\n      throw error;\n    }\n  }\n\n  async setItemTtl(index, ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    let existingItem = await this.get(index);\n    const requestBody = {\n      ttl\n    };\n    const response = await this.services.network.post(existingItem.uri, requestBody);\n    existingItem.updateDateExpires(response.body.date_expires);\n  }\n\n  async removeList() {\n    await this.services.network.delete(this.uri);\n    this.onRemoved(true);\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\n   * Handle update, which came from the server.\n   * @private\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    const itemIndex = Number(update.item_index);\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'list_item_added':\n      case 'list_item_updated':\n        {\n          this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires\n          update.type === 'list_item_added', true);\n        }\n        break;\n\n      case 'list_item_removed':\n        {\n          this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'list_context_updated':\n        {\n          this._handleContextUpdate(update.context_data, update.id, update.date_created);\n        }\n        break;\n\n      case 'list_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.list_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(index, uri, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(index, lastEventId)) {\n      logger_1.default.trace('Item ', index, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    } else {\n      this._updateRootDateUpdated(dateUpdated);\n\n      let item = this.cache.get(index);\n\n      if (!item) {\n        let item = new listitem_1.ListItem({\n          index,\n          uri,\n          lastEventId,\n          revision,\n          value,\n          dateUpdated,\n          dateExpires\n        });\n        this.cache.store(index, item, lastEventId);\n        this.emitItemMutationEvent(item, remote, added);\n      } else if (item.lastEventId < lastEventId) {\n        item.update(lastEventId, revision, value, dateUpdated);\n\n        if (dateExpires !== undefined) {\n          item.updateDateExpires(dateExpires);\n        }\n\n        this.emitItemMutationEvent(item, remote, false);\n      }\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  emitItemMutationEvent(item, remote, added) {\n    let eventName = added ? 'itemAdded' : 'itemUpdated';\n    this.broadcastEventToListeners(eventName, {\n      item: item,\n      isLocal: !remote\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(index, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      index: index,\n      isLocal: !remote,\n      value: oldData\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleContextUpdate(data, eventId, dateUpdated) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    if (this._updateContextIfRequired(data, eventId)) {\n      this.broadcastEventToListeners('contextUpdated', {\n        context: data,\n        isLocal: false\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _updateContextIfRequired(data, eventId) {\n    if (!this.contextEventId || eventId > this.contextEventId) {\n      this.context = data;\n      this.contextEventId = eventId;\n      return true;\n    } else {\n      logger_1.default.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);\n      return false;\n    }\n  }\n\n}\n\nexports.SyncListImpl = SyncListImpl;\n/**\n * @class\n * @alias List\n * @classdesc Represents a Sync List, which stores an ordered list of values.\n * Use the {@link Client#list} method to obtain a reference to a Sync List.\n * @property {String} sid - List unique id, immutable identifier assigned by the system.\n * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation.\n * @property {Date} dateUpdated Date when the List was last updated.\n *\n * @fires List#removed\n * @fires List#itemAdded\n * @fires List#itemRemoved\n * @fires List#itemUpdated\n */\n\nclass SyncList extends closeable_1.default {\n  // private props\n  get uri() {\n    return this.syncListImpl.uri;\n  }\n\n  get revision() {\n    return this.syncListImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncListImpl.lastEventId;\n  }\n\n  get links() {\n    return this.syncListImpl.links;\n  }\n\n  get dateExpires() {\n    return this.syncListImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncListImpl.type;\n  }\n\n  get type() {\n    return SyncListImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncListImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncListImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncListImpl.dateUpdated;\n  }\n\n  constructor(syncListImpl) {\n    super();\n    this.syncListImpl = syncListImpl;\n    this.syncListImpl.attach(this);\n  }\n  /**\n   * Add a new item to the list.\n   * @param {Object} value Value to be added.\n   * @param {List#ItemMetadata} [itemMetadata] Item metadata.\n   * @returns {Promise<ListItem>} A newly added item.\n   * @public\n   * @example\n   * list.push({ name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('List Item push() successful, item index:' + item.index + ', value: ', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item push() failed', error);\n   *   });\n   */\n\n\n  async push(value, itemMetadata) {\n    this.ensureNotClosed();\n    return this.syncListImpl.push(value, itemMetadata);\n  }\n  /**\n   * Assign new value to an existing item, given its index.\n   * @param {Number} index Index of the item to be updated.\n   * @param {Object} value New value to be assigned to an item.\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<ListItem>} A promise with updated item containing latest known value.\n   * The promise will be rejected if the item does not exist.\n   * @public\n   * @example\n   * list.set(42, { name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('List Item set() successful, item value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item set() failed', error);\n   *   });\n   */\n\n\n  async set(index, value, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncListImpl.set(index, value, itemMetadataUpdates);\n  }\n  /**\n   * Modify an existing item by applying a mutation function to it.\n   * @param {Number} index Index of an item to be changed.\n   * @param {List~Mutator} mutator A function that outputs a new value based on the existing value.\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<ListItem>} Resolves with the most recent item state, the output of a successful\n   *    mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>). This promise\n   *    will be rejected if the indicated item does not already exist.\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * list.mutate(42, mutatorFunction, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('List Item mutate() successful, new value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item mutate() failed', error);\n   *   });\n   */\n\n\n  async mutate(index, mutator, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncListImpl.mutate(index, mutator, itemMetadataUpdates);\n  }\n  /**\n   * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.\n   * This is equivalent to\n   * <pre>\n   * list.mutate(42, function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {Number} index Index of an item to be changed.\n   * @param {Object} obj Set of fields to update.\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.\n   * The promise will be rejected if an item was not found.\n   * @public\n   * @example\n   * // Say, the List Item (index: 42) value is { name: 'John Smith' }\n   * list.update(42, { age: 34 }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     // Now the List Item value is { name: 'John Smith', age: 34 }\n   *     console.log('List Item update() successful, new value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item update() failed', error);\n   *   });\n   */\n\n\n  async update(index, obj, itemMetadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncListImpl.update(index, obj, itemMetadataUpdates);\n  }\n  /**\n   * Delete an item, given its index.\n   * @param {Number} index Index of an item to be removed.\n   * @returns {Promise<void>} A promise to remove an item.\n   * A promise will be rejected if an item was not found.\n   * @public\n   * @example\n   * list.remove(42)\n   *   .then(function() {\n   *     console.log('List Item remove() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item remove() failed', error);\n   *   });\n   */\n\n\n  async remove(index) {\n    this.ensureNotClosed();\n    return this.syncListImpl.remove(index);\n  }\n  /**\n   * Retrieve an item by List index.\n   * @param {Number} index Item index in a List.\n   * @returns {Promise<ListItem>} A promise with an item containing latest known value.\n   * A promise will be rejected if an item was not found.\n   * @public\n   * @example\n   * list.get(42)\n   *   .then(function(item) {\n   *     console.log('List Item get() successful, item value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item get() failed', error);\n   *   });\n   */\n\n\n  async get(index) {\n    this.ensureNotClosed();\n    return this.syncListImpl.get(index);\n  }\n  /**\n   * Retrieve a List context\n   * @returns {Promise<Object>} A promise with a List's context\n   * @ignore\n   */\n\n\n  async getContext() {\n    this.ensureNotClosed();\n    return this.syncListImpl.getContext();\n  }\n  /**\n   * Query a list of items from collection.\n   * @param {Object} [args] Arguments for query\n   * @param {Number} [args.from] Item index, which should be used as the offset.\n   * If undefined, starts from the beginning or end depending on args.order.\n   * @param {Number} [args.pageSize=50] Results page size.\n   * @param {'asc'|'desc'} [args.order='asc'] Numeric order of results.\n   * @returns {Promise<Paginator<ListItem>>}\n   * @public\n   * @example\n   * var pageHandler = function(paginator) {\n   *   paginator.items.forEach(function(item) {\n   *     console.log('Item ' + item.index + ': ', item.value);\n   *   });\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n   *                                : null;\n   * };\n   * list.getItems({ from: 0, order: 'asc' })\n   *   .then(pageHandler)\n   *   .catch(function(error) {\n   *     console.error('List getItems() failed', error);\n   *   });\n   */\n\n\n  async getItems(args) {\n    this.ensureNotClosed();\n    return this.syncListImpl.getItems(args);\n  }\n  /**\n   * Update the time-to-live of the list.\n   * @param {Number} ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * list.setTtl(3600)\n   *   .then(function() {\n   *     console.log('List setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncListImpl.setTtl(ttl);\n  }\n  /**\n   * Update the time-to-live of a list item.\n   * @param {Number} index Item index.\n   * @param {Number} ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * list.setItemTtl(42, 86400)\n   *   .then(function() {\n   *     console.log('List setItemTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List setItemTtl() failed', error);\n   *   });\n   */\n\n\n  async setItemTtl(index, ttl) {\n    this.ensureNotClosed();\n    return this.syncListImpl.setItemTtl(index, ttl);\n  }\n  /**\n   * Delete this list. It will be impossible to restore it.\n   * @return {Promise<void>} A promise that resolves when the list has been deleted.\n   * @public\n   * @example\n   * list.removeList()\n   *   .then(function() {\n   *     console.log('List removeList() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List removeList() failed', error);\n   *   });\n   */\n\n\n  async removeList() {\n    this.ensureNotClosed();\n    return this.syncListImpl.removeList();\n  }\n  /**\n   * Conclude work with the list instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this list will continue operating and receiving events normally.\n   * @public\n   * @example\n   * list.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncListImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncList = SyncList;\nexports.default = SyncList;\n/**\n * Contains List Item metadata.\n * @typedef {Object} List#ItemMetadata\n * @property {String} [ttl] Specifies the time-to-live in seconds after which the list item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback List~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the list, whether its creator was local or remote.\n * @event List#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * list.on('itemAdded', function(args) {\n *   console.log('List item ' + args.item.index + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event List#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * list.on('itemUpdated', function(args) {\n *   console.log('List item ' + args.item.index + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list item is removed, whether the remover was local or remote.\n * @event List#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {Number} args.index The index of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * list.on('itemRemoved', function(args) {\n *   console.log('List item ' + args.index + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list is deleted entirely, by any actor local or remote.\n * @event List#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if list was removed by local actor, 'false' otherwise.\n * @example\n * list.on('removed', function(args) {\n *   console.log('List ' + list.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":null,"metadata":{},"sourceType":"script"}