{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"./logger\");\n\nfunction byteLength(s) {\n  let escstr = encodeURIComponent(s);\n  let binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));\n  return binstr.length;\n}\n\nfunction stringToUint8Array(s) {\n  let escstr = encodeURIComponent(s);\n  let binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1));\n  let ua = new Uint8Array(binstr.length);\n  Array.prototype.forEach.call(binstr, (ch, i) => {\n    ua[i] = ch.charCodeAt(0);\n  });\n  return ua;\n}\n\nfunction uint8ArrayToString(ua) {\n  let binstr = Array.prototype.map.call(ua, ch => String.fromCharCode(ch)).join('');\n  let escstr = binstr.replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n\n    if (code.length < 2) {\n      code = '0' + code;\n    }\n\n    return '%' + code;\n  });\n  return decodeURIComponent(escstr);\n}\n\nfunction getJsonObject(array) {\n  return JSON.parse(uint8ArrayToString(array));\n}\n\nfunction getMagic(buffer) {\n  let strMagic = '';\n  let idx = 0;\n\n  for (; idx < buffer.length; ++idx) {\n    const chr = String.fromCharCode(buffer[idx]);\n    strMagic += chr;\n\n    if (chr === '\\r') {\n      idx += 2;\n      break;\n    }\n  }\n\n  const magics = strMagic.split(' ');\n  return {\n    size: idx,\n    protocol: magics[0],\n    version: magics[1],\n    headerSize: Number(magics[2])\n  };\n}\n\nclass Parser {\n  constructor() {}\n\n  static parse(message) {\n    const fieldMargin = 2;\n    const dataView = new Uint8Array(message);\n    const magic = getMagic(dataView);\n\n    if (magic.protocol !== 'TWILSOCK' || magic.version !== 'V3.0') {\n      logger_1.log.error(\"unsupported protocol: \".concat(magic.protocol, \" ver \").concat(magic.version)); //throw new Error('Unsupported protocol');\n      //this.fsm.unsupportedProtocol();\n\n      return;\n    }\n\n    let header = null;\n\n    try {\n      header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));\n    } catch (e) {\n      logger_1.log.error('failed to parse message header', e, message); //throw new Error('Failed to parse message');\n      //this.fsm.protocolError();\n\n      return;\n    }\n\n    logger_1.log.debug('message received: ', header.method);\n    logger_1.log.trace('message received: ', header);\n    let payload = null;\n\n    if (header.payload_size > 0) {\n      const payloadOffset = fieldMargin + magic.size + magic.headerSize;\n      const payloadSize = header.payload_size;\n\n      if (!header.hasOwnProperty('payload_type') || header.payload_type.indexOf('application/json') === 0) {\n        try {\n          payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n        } catch (e) {\n          logger_1.log.error('failed to parse message body', e, message); //this.fsm.protocolError();\n\n          return;\n        }\n      } else if (header.payload_type.indexOf('text/plain') === 0) {\n        payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n      }\n    }\n\n    return {\n      method: header.method,\n      header,\n      payload\n    };\n  }\n\n  static createPacket(header, payloadString = '') {\n    header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase\n\n    let headerString = JSON.stringify(header) + '\\r\\n';\n    let magicString = 'TWILSOCK V3.0 ' + (byteLength(headerString) - 2) + '\\r\\n';\n    logger_1.log.debug('send request:', magicString + headerString + payloadString);\n    let message = stringToUint8Array(magicString + headerString + payloadString);\n    return message.buffer;\n  }\n\n}\n\nexports.Parser = Parser;","map":null,"metadata":{},"sourceType":"script"}