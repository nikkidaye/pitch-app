{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst logger_1 = require(\"./logger\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst twilsock_1 = require(\"./twilsock\");\n\nconst packetinterface_1 = require(\"./packetinterface\");\n\nconst websocketchannel_1 = require(\"./websocketchannel\");\n\nconst registrations_1 = require(\"./services/registrations\");\n\nconst upstream_1 = require(\"./services/upstream\");\n\nconst deferred_1 = require(\"./deferred\");\n\nconst index_1 = require(\"./index\");\n\nconst offlinestorage_1 = require(\"./offlinestorage\");\n\nconst tokenStorage_1 = require(\"./tokenStorage\");\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\n\n\nclass TwilsockClient extends events_1.EventEmitter {\n  /**\n   * @param {string} token Twilio access token\n   * @param {string} productId Product identifier. Should be the same as a grant name in token\n   */\n  constructor(token, productId, options = {}) {\n    super();\n    this.offlineStorageDeferred = new deferred_1.Deferred();\n    options.continuationToken = options.continuationToken ? options.continuationToken : tokenStorage_1.TokenStorage.getStoredToken(productId);\n    let config = this.config = new configuration_1.Configuration(token, productId, options);\n    logger_1.log.setLevel(config.logLevel);\n    let websocket = new websocketchannel_1.WebSocketChannel(config.url);\n    let transport = options.transport ? options.transport : new packetinterface_1.PacketInterface(websocket, config);\n    this.channel = options.channel ? options.channel : new twilsock_1.TwilsockImpl(websocket, transport, config);\n    this.registrations = options.registrations ? options.registrations : new registrations_1.Registrations(transport);\n    this.upstream = new upstream_1.Upstream(transport, this.channel, config);\n    this.registrations.on('registered', id => this.emit('registered', id));\n    this.channel.on('message', (type, message) => setTimeout(() => this.emit('message', type, message), 0));\n    this.channel.on('stateChanged', state => setTimeout(() => this.emit('stateChanged', state), 0));\n    this.channel.on('connectionError', connectionError => setTimeout(() => this.emit('connectionError', connectionError), 0));\n    this.channel.on('tokenAboutToExpire', () => setTimeout(() => this.emit('tokenAboutToExpire'), 0));\n    this.channel.on('tokenExpired', () => setTimeout(() => this.emit('tokenExpired'), 0));\n    this.channel.on('connected', () => this.registrations.updateRegistrations());\n    this.channel.on('connected', () => this.upstream.sendPendingMessages());\n    this.channel.on('connected', () => setTimeout(() => this.emit('connected'), 0));\n    this.channel.on('initialized', initReply => {\n      this.handleStorageId(productId, initReply);\n      tokenStorage_1.TokenStorage.storeToken(initReply.continuationToken, productId);\n      setTimeout(() => this.emit('initialized', initReply), 0);\n    });\n    this.channel.on('disconnected', () => setTimeout(() => this.emit('disconnected'), 0));\n    this.channel.on('disconnected', () => this.upstream.rejectPendingMessages());\n    this.channel.on('disconnected', () => this.offlineStorageDeferred.fail(new index_1.TwilsockError('Client disconnected')));\n    this.offlineStorageDeferred.promise.catch(() => {});\n  }\n\n  emit(event, ...args) {\n    logger_1.log.debug(\"Emitting \".concat(event.toString(), \"(\").concat(args.map(a => JSON.stringify(a)).join(', '), \")\"));\n    return super.emit(event, ...args);\n  }\n\n  handleStorageId(productId, initReply) {\n    if (!initReply.offlineStorage) {\n      this.offlineStorageDeferred.fail(new index_1.TwilsockError('No offline storage id'));\n    } else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n      try {\n        this.offlineStorageDeferred.set(offlinestorage_1.OfflineProductStorage.create(initReply.offlineStorage[productId]));\n        logger_1.log.debug(\"Offline storage for '\".concat(productId, \"' product: \").concat(JSON.stringify(initReply.offlineStorage[productId]), \".\"));\n      } catch (e) {\n        this.offlineStorageDeferred.fail(new index_1.TwilsockError(\"Failed to parse offline storage for \".concat(productId, \" \").concat(JSON.stringify(initReply.offlineStorage[productId]), \". \").concat(e, \".\")));\n      }\n    } else {\n      this.offlineStorageDeferred.fail(new index_1.TwilsockError(\"No offline storage id for '\".concat(productId, \"' product: \").concat(JSON.stringify(initReply.offlineStorage))));\n    }\n  }\n  /**\n   * Get offline storage ID\n   * @returns {Promise<OfflineProductStorage>}\n   */\n\n\n  storageId() {\n    return this.offlineStorageDeferred.promise;\n  }\n  /**\n   * Indicates if twilsock is connected now\n   * @returns {Boolean}\n   */\n\n\n  get isConnected() {\n    return this.channel.isConnected;\n  }\n  /**\n   * Current state\n   * @returns {String}\n   */\n\n\n  get state() {\n    return this.channel.state;\n  }\n  /**\n   * Update token\n   * @param {String} token\n   * @returns {Promise<void>}\n   */\n\n\n  async updateToken(token) {\n    logger_1.log.trace(\"updating token '\".concat(token, \"'\"));\n\n    if (this.config.token === token) {\n      return;\n    }\n\n    this.config.updateToken(token);\n    return this.channel.updateToken(token);\n  }\n  /**\n   * Updates notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @param context value of notification context\n   * @private\n   */\n\n\n  setNotificationsContext(contextId, context) {\n    this.registrations.setNotificationsContext(contextId, context);\n  }\n  /**\n   * Remove notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @private\n   */\n\n\n  removeNotificationsContext(contextId) {\n    this.registrations.removeNotificationsContext(contextId);\n  }\n  /**\n   * Connect to the server\n   * @fires Twilsock#connected\n   * @public\n   * @returns {Promise<void>}\n   */\n\n\n  connect() {\n    return this.channel.connect();\n  }\n  /**\n   * Disconnect from the server\n   * @fires Twilsock#disconnected\n   * @public\n   * @returns {Promise<void>}\n   */\n\n\n  disconnect() {\n    return this.channel.disconnect();\n  }\n  /**\n   * Get HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @returns {Promise}\n   */\n\n\n  get(url, headers) {\n    return this.upstream.send('GET', url, headers);\n  }\n  /**\n   * Post HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @returns {Promise}\n   */\n\n\n  post(url, headers, body) {\n    return this.upstream.send('POST', url, headers, body);\n  }\n  /**\n   * Put HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @returns {Promise}\n   */\n\n\n  put(url, headers, body) {\n    return this.upstream.send('PUT', url, headers, body);\n  }\n  /**\n   * Delete HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @returns {Promise}\n   */\n\n\n  delete(url, headers) {\n    return this.upstream.send('DELETE', url, headers);\n  }\n\n}\n\nexports.TwilsockClient = TwilsockClient;\nexports.Twilsock = TwilsockClient;\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n\n/**\n* Fired when socket connected\n* @param {('connecting'|'connected'|'rejected'|'disconnecting'|'disconnected')} state - general twilsock state\n* @event Twilsock#stateChanged\n*/\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */","map":null,"metadata":{},"sourceType":"script"}