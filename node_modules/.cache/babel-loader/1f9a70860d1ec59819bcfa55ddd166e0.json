{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/nikkid/Desktop/wyncode/pitch-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst operation_retrier_1 = require(\"operation-retrier\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\n\n\nclass SubscribedEntity {\n  constructor(entity) {\n    this.localObject = entity;\n    this.pendingCorrelationId = null;\n    this.pendingAction = null;\n    this.established = false;\n    this.retryCount = 0;\n  }\n\n  get sid() {\n    return this.localObject.sid;\n  }\n\n  get type() {\n    return this.localObject.type;\n  }\n\n  get lastEventId() {\n    return this.localObject.lastEventId;\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return this.localObject.indexName;\n  }\n\n  get queryString() {\n    return this.localObject.queryString;\n  }\n\n  get isEstablished() {\n    return this.established;\n  }\n\n  update(event, isStrictlyOrdered) {\n    this.localObject._update(event, isStrictlyOrdered);\n  }\n\n  updatePending(action, correlationId) {\n    this.pendingAction = action;\n    this.pendingCorrelationId = correlationId;\n  }\n\n  reset() {\n    this.updatePending(null, null);\n    this.retryCount = 0;\n    this.established = false;\n    this.setSubscriptionState('none');\n  }\n\n  markAsFailed(message) {\n    this.rejectedWithError = message.error;\n    this.updatePending(null, null);\n    this.localObject.reportFailure(new syncerror_1.SyncError(\"Failed to subscribe on service events: \".concat(message.error.message), message.error.status, message.error.code));\n  }\n\n  complete(eventId) {\n    this.updatePending(null, null);\n    this.established = true;\n\n    this.localObject._advanceLastEventId(eventId);\n  }\n\n  setSubscriptionState(newState) {\n    this.localObject._setSubscriptionState(newState);\n  }\n\n}\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\n\n\nclass Subscriptions {\n  /**\n   * @constructor\n   * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n   *\n   * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n   *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n   *\n   * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n   */\n  constructor(services) {\n    this.isConnected = false;\n    this.maxBatchSize = 100; // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n    // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n    // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n\n    this.subscriptionTtlTimer = null;\n    this.pendingPokeReason = null;\n    this.services = services;\n    this.subscriptions = new Map();\n    this.persisted = new Map();\n    this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n    const defaultBackoffConfig = {\n      randomisationFactor: 0.2,\n      initialDelay: 100,\n      maxDelay: 2 * 60 * 1000\n    };\n    this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig)); // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n    // backoff 'ready' event, at which point a new subscription set is calculated.\n\n    this.backoff.on('ready', () => {\n      let _this$getSubscription = this.getSubscriptionUpdateBatch(),\n          action = _this$getSubscription.action,\n          subscriptionRequests = _this$getSubscription.subscriptions;\n\n      if (action) {\n        this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n      } else {\n        this.backoff.reset();\n        logger_1.default.debug('All subscriptions resolved.');\n      }\n    });\n  }\n\n  getSubscriptionUpdateBatch() {\n    function subtract(these, those, action, limit) {\n      let result = [];\n\n      for (let _ref of these) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        let thisKey = _ref2[0];\n        let thisValue = _ref2[1];\n        const otherValue = those.get(thisKey);\n\n        if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n          result.push(thisValue);\n\n          if (limit && result.length >= limit) {\n            break;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n\n    if (listToAdd.length > 0) {\n      return {\n        action: 'establish',\n        subscriptions: listToAdd\n      };\n    }\n\n    let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n\n    if (listToRemove.length > 0) {\n      return {\n        action: 'cancel',\n        subscriptions: listToRemove\n      };\n    }\n\n    return {\n      action: null,\n      subscriptions: null\n    };\n  }\n\n  persist() {\n    this.backoff.backoff();\n  }\n\n  async applyNewSubscriptionUpdateBatch(action, requests) {\n    if (!this.isConnected) {\n      logger_1.default.debug(\"Twilsock connection (required for subscription) not ready; waiting\\u2026\");\n      this.backoff.reset();\n      return;\n    } // Keeping in mind that events may begin flowing _before_ we receive the response\n\n\n    requests = this.processLocalActions(action, requests);\n    const correlationId = new Date().getTime();\n\n    for (const subscribed of requests) {\n      this.recordActionAttemptOn(subscribed, action, correlationId);\n    }\n\n    let reason = this.pendingPokeReason;\n    this.pendingPokeReason = null; // Send this batch to the service\n\n    try {\n      let response = await this.request(action, correlationId, reason, requests);\n      let newMaxBatchSize = response.body.max_batch_size;\n\n      if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n        this.maxBatchSize = newMaxBatchSize;\n      }\n\n      if (!this.subscriptionTtlTimer) {\n        let subscriptionTtlInS = response.body.ttl_in_s;\n        let isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n        let isValidTtl = isNumeric && subscriptionTtlInS > 0;\n\n        if (isValidTtl) {\n          this.subscriptionTtlTimer = setTimeout(() => this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);\n        }\n      }\n\n      if (action === 'establish') {\n        const estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n        let isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n        let isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;\n\n        if (isValidTimeout) {\n          setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);\n        } else {\n          logger_1.default.error(\"Invalid timeout: \".concat(estimatedDeliveryInMs));\n        }\n\n        requests.filter(r => r.pendingCorrelationId === correlationId).forEach(r => r.setSubscriptionState('response_in_flight'));\n      }\n\n      this.backoff.reset();\n    } catch (e) {\n      for (const attemptedSubscription of requests) {\n        this.recordActionFailureOn(attemptedSubscription, action);\n      }\n\n      if (e instanceof twilsock_1.TransportUnavailableError) {\n        logger_1.default.debug(\"Twilsock connection (required for subscription) not ready (c:\".concat(correlationId, \"); waiting\\u2026\"));\n        this.backoff.reset();\n      } else {\n        logger_1.default.debug(\"Failed an attempt to \".concat(action, \" subscriptions (c:\").concat(correlationId, \"); retrying\"), e);\n        this.persist();\n      }\n    }\n  }\n\n  verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n    const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n    const silencePeriod = lastReceived ? new Date().getTime() - lastReceived : estimatedDeliveryInMs;\n\n    if (silencePeriod >= estimatedDeliveryInMs) {\n      // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n      requests.filter(r => r.pendingCorrelationId === correlationId).forEach(r => {\n        r.updatePending(null, null);\n        r.retryCount++;\n        this.persisted.delete(r.sid);\n      });\n      this.persist();\n      this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n    } else {\n      // Otherwise, the poke responses are probably in transit and we should wait for them\n      const timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n      setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);\n    }\n  }\n\n  processLocalActions(action, requests) {\n    if (action === 'cancel') {\n      return requests.filter(request => !request.rejectedWithError);\n    }\n\n    return requests;\n  }\n\n  recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n    attemptedSubscription.setSubscriptionState('request_in_flight');\n\n    if (action === 'establish') {\n      this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n      attemptedSubscription.updatePending(action, correlationId);\n    } else {\n      // cancel\n      let persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n\n      if (persistedSubscription) {\n        persistedSubscription.updatePending(action, correlationId);\n      }\n    }\n  }\n\n  recordActionFailureOn(attemptedSubscription, action) {\n    attemptedSubscription.setSubscriptionState('none');\n    attemptedSubscription.updatePending(null, null);\n\n    if (action === 'establish') {\n      this.persisted.delete(attemptedSubscription.sid);\n    }\n  }\n\n  request(action, correlationId, reason, objects) {\n    let requests = objects.map(object => ({\n      object_sid: object.sid,\n      object_type: object.type,\n      last_event_id: action === 'establish' ? object.lastEventId : undefined,\n      index_name: action === 'establish' ? object.indexName : undefined,\n      query_string: action === 'establish' ? object.queryString : undefined\n    }));\n    let retriedRequests = objects.filter(a => a.retryCount > 0).length;\n    logger_1.default.debug(\"Attempting '\".concat(action, \"' request (c:\").concat(correlationId, \"):\"), requests);\n    const requestBody = {\n      event_protocol_version: 3,\n      action,\n      correlation_id: correlationId,\n      retried_requests: retriedRequests,\n      ttl_in_s: -1,\n      requests\n    };\n\n    if (reason === 'ttl') {\n      requestBody.reason = reason;\n    }\n\n    return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n  }\n  /**\n   * Establishes intent to be subscribed to this entity. That subscription will be effected\n   * asynchronously.\n   * If subscription to the given sid already exists, it will be overwritten.\n   *\n   * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n   * @param {Object} entity should represent the (singular) local representation of this entity.\n   *      Incoming events and modifications to the entity will be directed at the _update() function\n   *      of this provided reference.\n   *\n   * @return undefined\n   */\n\n\n  add(sid, entity) {\n    logger_1.default.debug(\"Establishing intent to subscribe to \".concat(sid));\n    const existingSubscription = this.subscriptions.get(sid);\n\n    if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n      // If last event id is the same as before - we're fine\n      return;\n    }\n\n    this.persisted.delete(sid);\n    this.subscriptions.set(sid, new SubscribedEntity(entity));\n    this.persist();\n  }\n  /**\n   * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n   * call, no further events shall be routed to the local representation of the entity, even\n   * though a server-side subscription may take more time to actually terminate.\n   *\n   * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n   *      This call only has meaningful effect if that entity is subscribed at the\n   *      time of call. Otherwise does nothing.\n   *\n   * @return undefined\n   */\n\n\n  remove(sid) {\n    logger_1.default.debug(\"Establishing intent to unsubscribe from \".concat(sid));\n    const removed = this.subscriptions.delete(sid);\n\n    if (removed) {\n      this.persist();\n    }\n  }\n  /**\n   * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n   * to which we are subscribed).\n   *\n   * @param {object} message is the full, unaltered body of the incoming notification.\n   *\n   * @return undefined\n   */\n\n\n  acceptMessage(message, isStrictlyOrdered) {\n    logger_1.default.trace('Subscriptions received', message);\n\n    if (message.correlation_id) {\n      this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n    }\n\n    switch (message.event_type) {\n      case 'subscription_established':\n        this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n        break;\n\n      case 'subscription_canceled':\n        this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n        break;\n\n      case 'subscription_failed':\n        this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n        break;\n\n      case (message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n        {\n          let typedSid = function () {\n            if (message.event_type.match(/^map_/)) {\n              return message.event.map_sid;\n            } else if (message.event_type.match(/^list_/)) {\n              return message.event.list_sid;\n            } else if (message.event_type.match(/^document_/)) {\n              return message.event.document_sid;\n            } else if (message.event_type.match(/^stream_/)) {\n              return message.event.stream_sid;\n            } else if (message.event_type.match(/^live_query/)) {\n              return message.event.query_id;\n            } else {\n              return undefined;\n            }\n          };\n\n          this.applyEventToSubscribedEntity(typedSid(), message, isStrictlyOrdered);\n        }\n        break;\n\n      default:\n        logger_1.default.debug(\"Dropping unknown message type \".concat(message.event_type));\n        break;\n    }\n  }\n\n  applySubscriptionEstablishedMessage(message, correlationId) {\n    const sid = message.object_sid;\n    let subscriptionIntent = this.persisted.get(message.object_sid);\n\n    if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n      if (message.replay_status === 'interrupted') {\n        logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") interrupted; continuing eagerly.\"));\n        subscriptionIntent.updatePending(null, null);\n        this.persisted.delete(subscriptionIntent.sid);\n        this.backoff.reset();\n      } else if (message.replay_status === 'completed') {\n        logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") completed. Subscription is ready.\"));\n        subscriptionIntent.complete(message.last_event_id);\n        this.persisted.set(message.object_sid, subscriptionIntent);\n        subscriptionIntent.setSubscriptionState('established');\n        this.backoff.reset();\n      }\n    } else {\n      logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n    }\n\n    this.persist();\n  }\n\n  applySubscriptionCancelledMessage(message, correlationId) {\n    let persistedSubscription = this.persisted.get(message.object_sid);\n\n    if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n      persistedSubscription.updatePending(null, null);\n      persistedSubscription.setSubscriptionState('none');\n      this.persisted.delete(message.object_sid);\n    } else {\n      logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n    }\n\n    this.persist();\n  }\n\n  applySubscriptionFailedMessage(message, correlationId) {\n    const sid = message.object_sid;\n    let subscriptionIntent = this.subscriptions.get(sid);\n    let subscription = this.persisted.get(sid);\n\n    if (subscriptionIntent && subscription) {\n      if (subscription.pendingCorrelationId === correlationId) {\n        logger_1.default.error(\"Failed to subscribe on \".concat(subscription.sid), message.error);\n        subscription.markAsFailed(message);\n        subscription.setSubscriptionState('none');\n      }\n    } else if (!subscriptionIntent && subscription) {\n      this.persisted.delete(sid);\n      subscription.setSubscriptionState('none');\n    }\n\n    this.persist();\n  }\n\n  applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n    if (!sid) {\n      return;\n    } // Looking for subscription descriptor to check if poke has been completed\n\n\n    isStrictlyOrdered = isStrictlyOrdered || (() => {\n      let subscription = this.persisted.get(sid);\n      return subscription && subscription.isEstablished;\n    })(); // Still searching for subscriptionIntents. User could remove subscription already\n\n\n    let subscriptionIntent = this.subscriptions.get(sid);\n\n    if (subscriptionIntent) {\n      message.event.type = message.event_type;\n      subscriptionIntent.update(message.event, isStrictlyOrdered);\n    } else {\n      logger_1.default.debug(\"Message dropped for SID '\".concat(sid, \"', for which there is no subscription.\"));\n    }\n  }\n\n  onConnectionStateChanged(isConnected) {\n    this.isConnected = isConnected;\n\n    if (isConnected) {\n      this.poke('reconnect');\n    }\n  }\n\n  onSubscriptionTtlElapsed() {\n    if (this.isConnected) {\n      this.poke('ttl');\n    }\n  }\n  /**\n   * Prompts a playback of any missed changes made to any subscribed object. This method\n   * should be invoked whenever the connectivity layer has experienced cross-cutting\n   * delivery failures that would affect the entire local sync set. Any tangible result\n   * of this operation will result in calls to the _update() function of subscribed\n   * Sync entities.\n   */\n\n\n  poke(reason) {\n    logger_1.default.debug(\"Triggering event replay for all subscriptions, reason=\".concat(reason));\n    this.pendingPokeReason = reason;\n\n    if (this.subscriptionTtlTimer) {\n      clearTimeout(this.subscriptionTtlTimer);\n      this.subscriptionTtlTimer = null;\n    }\n\n    let failedSubscriptions = [];\n\n    for (let it of this.persisted.values()) {\n      it.reset();\n\n      if (it.rejectedWithError) {\n        failedSubscriptions.push(it);\n      }\n    }\n\n    this.persisted.clear();\n\n    for (let it of failedSubscriptions) {\n      this.persisted.set(it.sid, it);\n    }\n\n    this.persist();\n  }\n  /**\n   * Stops all communication, clears any subscription intent, and returns.\n   */\n\n\n  shutdown() {\n    this.backoff.reset();\n    this.subscriptions.clear();\n  }\n\n}\n\nexports.Subscriptions = Subscriptions;","map":null,"metadata":{},"sourceType":"script"}