{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"../logger\");\n\nconst events_1 = require(\"events\");\n\nconst uuid_1 = require(\"uuid\");\n\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\n/**\n * Registrations module handles all operations with registration contexts through twilsock\n * Main role: it automatically refreshes all registrations after reconnect.\n */\n\n\nclass Registrations extends events_1.EventEmitter {\n  constructor(transport) {\n    super();\n    this.transport = transport;\n    this.registrations = new Map();\n    this.registrationsInProgress = new Map();\n  }\n\n  async putNotificationContext(contextId, context) {\n    const header = {\n      method: 'put_notification_ctx',\n      notification_ctx_id: contextId\n    };\n    let reply = await this.transport.sendWithReply(header, context);\n  }\n\n  async deleteNotificationContext(contextId) {\n    let message = {\n      method: 'delete_notification_ctx',\n      notification_ctx_id: contextId\n    };\n    let reply = await this.transport.sendWithReply(message);\n  }\n\n  async updateRegistration(contextId, context) {\n    logger_1.log.debug('update registration for context', contextId);\n    let registrationAttempts = this.registrationsInProgress.get(contextId);\n\n    if (!registrationAttempts) {\n      registrationAttempts = new Set();\n      this.registrationsInProgress.set(contextId, registrationAttempts);\n    }\n\n    const attemptId = uuid_1.v4();\n    registrationAttempts.add(attemptId);\n\n    try {\n      await this.putNotificationContext(contextId, context);\n      logger_1.log.debug('registration attempt succeeded for context', context);\n      registrationAttempts.delete(attemptId);\n\n      if (registrationAttempts.size === 0) {\n        this.registrationsInProgress.delete(contextId);\n        this.emit('registered', contextId);\n      }\n    } catch (err) {\n      logger_1.log.warn('registration attempt failed for context', context);\n      logger_1.log.debug(err);\n      registrationAttempts.delete(attemptId);\n\n      if (registrationAttempts.size === 0) {\n        this.registrationsInProgress.delete(contextId);\n        this.emit('registrationFailed', contextId, err);\n      }\n    }\n  }\n\n  updateRegistrations() {\n    logger_1.log.trace(\"refreshing \".concat(this.registrations.size, \" registrations\"));\n    this.registrations.forEach((context, id) => {\n      this.updateRegistration(id, context);\n    });\n  }\n\n  setNotificationsContext(contextId, context) {\n    if (!contextId || !context) {\n      throw new twilsockerror_1.TwilsockError('Invalid arguments provided');\n    }\n\n    this.registrations.set(contextId, context);\n\n    if (this.transport.isConnected) {\n      this.updateRegistration(contextId, context);\n    }\n  }\n\n  async removeNotificationsContext(contextId) {\n    if (!this.registrations.has(contextId)) {\n      return;\n    }\n\n    await this.deleteNotificationContext(contextId);\n\n    if (this.transport.isConnected) {\n      this.registrations.delete(contextId);\n    }\n  }\n\n}\n\nexports.Registrations = Registrations;","map":null,"metadata":{},"sourceType":"script"}