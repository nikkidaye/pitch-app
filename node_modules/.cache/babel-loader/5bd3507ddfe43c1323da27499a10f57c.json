{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncDocumentImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n    this.isDeleted = false;\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.MergingQueue(updateRequestReducer);\n    this.descriptor = descriptor;\n    this.descriptor.data = this.descriptor.data || {};\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'document';\n  }\n\n  get type() {\n    return 'document';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get value() {\n    return this.descriptor.data;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n  /**\n   * Update data entity with new data\n   * @private\n   */\n\n\n  _update(update) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'document_updated':\n        if (update.id > this.lastEventId) {\n          this.descriptor.last_event_id = update.id;\n          this.descriptor.revision = update.document_revision;\n          this.descriptor.date_updated = update.date_created;\n          this.descriptor.data = update.document_data;\n          this.broadcastEventToListeners('updated', {\n            value: update.document_data,\n            isLocal: false\n          });\n          this.services.storage.update(this.type, this.sid, this.uniqueName, {\n            last_event_id: update.id,\n            revision: update.document_revision,\n            date_updated: update.date_created,\n            data: update.document_data\n          });\n        } else {\n          logger_1.default.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);\n        }\n\n        break;\n\n      case 'document_removed':\n        this.onRemoved(false);\n        break;\n    }\n  }\n\n  async set(value, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.squashAndAdd(input, input => this._setUnconditionally(value, input.ttl));\n  }\n\n  async mutate(mutator, metadataUpdates) {\n    const input = metadataUpdates || {};\n    sanitize_1.validateOptionalTtl(input.ttl);\n    return this.updateMergingQueue.add(input, input => this._setWithIfMatch(mutator, input.ttl));\n  }\n\n  async update(obj, metadataUpdates) {\n    return this.mutate(remote => Object.assign(remote, obj), metadataUpdates);\n  }\n\n  async setTtl(ttl) {\n    sanitize_1.validateMandatoryTtl(ttl);\n    const response = await this._postUpdateToServer({\n      ttl\n    });\n    this.descriptor.date_expires = response.date_expires;\n  }\n  /**\n   * @private\n   */\n\n\n  async _setUnconditionally(value, ttl) {\n    let result = await this._postUpdateToServer({\n      data: value,\n      revision: undefined,\n      ttl\n    });\n\n    this._handleSuccessfulUpdateResult(result);\n\n    return this.value;\n  }\n  /**\n   * @private\n   */\n\n\n  async _setWithIfMatch(mutatorFunction, ttl) {\n    let data = mutatorFunction(sanitize_1.deepClone(this.value));\n\n    if (data) {\n      let revision = this.revision;\n\n      try {\n        let result = await this._postUpdateToServer({\n          data,\n          revision,\n          ttl\n        });\n\n        this._handleSuccessfulUpdateResult(result);\n\n        return this.value;\n      } catch (error) {\n        if (error.status === 412) {\n          await this._softSync();\n          return this._setWithIfMatch(mutatorFunction);\n        } else {\n          throw error;\n        }\n      }\n    } else {\n      return this.value;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _handleSuccessfulUpdateResult(result) {\n    if (result.last_event_id > this.descriptor.last_event_id) {\n      // Ignore returned value if we already got a newer one\n      this.descriptor.revision = result.revision;\n      this.descriptor.data = result.data;\n      this.descriptor.last_event_id = result.last_event_id;\n      this.descriptor.date_expires = result.date_expires;\n      this.descriptor.date_updated = new Date(result.date_updated);\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        last_event_id: result.last_event_id,\n        revision: result.revision,\n        date_updated: result.date_updated,\n        data: result.data\n      });\n      this.broadcastEventToListeners('updated', {\n        value: this.value,\n        isLocal: true\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  async _postUpdateToServer(request) {\n    if (!this.isDeleted) {\n      const requestBody = {\n        data: request.data\n      };\n\n      if (typeof request.ttl === 'number') {\n        requestBody.ttl = request.ttl;\n      }\n\n      const ifMatch = request.revision;\n\n      try {\n        const response = await this.services.network.post(this.uri, requestBody, ifMatch);\n        return {\n          revision: response.body.revision,\n          data: request.data,\n          last_event_id: response.body.last_event_id,\n          date_updated: response.body.date_updated,\n          date_expires: response.body.date_expires\n        };\n      } catch (error) {\n        if (error.status === 404) {\n          this.onRemoved(false);\n        }\n\n        throw error;\n      }\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n  /**\n   * Get new data from server\n   * @private\n   */\n\n\n  async _softSync() {\n    return this.services.network.get(this.uri).then(response => {\n      const event = {\n        type: 'document_updated',\n        id: response.body.last_event_id,\n        document_revision: response.body.revision,\n        document_data: response.body.data,\n        date_created: response.body.date_updated\n      };\n\n      this._update(event);\n\n      return this;\n    }).catch(err => {\n      if (err.status === 404) {\n        this.onRemoved(false);\n      } else {\n        logger_1.default.error(\"Can't get updates for \".concat(this.sid, \":\"), err);\n      }\n    });\n  }\n\n  onRemoved(locally) {\n    if (this.isDeleted) {\n      return;\n    } else {\n      this.isDeleted = true;\n\n      this._unsubscribe();\n\n      this.removalHandler(this.type, this.sid, this.uniqueName);\n      this.broadcastEventToListeners('removed', {\n        isLocal: locally\n      });\n    }\n  }\n\n  async removeDocument() {\n    if (!this.isDeleted) {\n      await this.services.network.delete(this.uri);\n      this.onRemoved(true);\n    } else {\n      return Promise.reject(new syncerror_1.SyncError('The Document has been removed', 404, 54100));\n    }\n  }\n\n}\n\nexports.SyncDocumentImpl = SyncDocumentImpl;\n/**\n * @class\n * @alias Document\n * @classdesc Represents a Sync Document, the contents of which is a single JSON object.\n * Use the {@link Client#document} method to obtain a reference to a Sync Document.\n * @property {String} sid The immutable identifier of this document, assigned by the system.\n * @property {String} [uniqueName=null] An optional immutable identifier that may be assigned by the programmer\n * to this document during creation. Globally unique among other Documents.\n * @property {Date} dateUpdated Date when the Document was last updated.\n * @property {Object} value The contents of this document.\n *\n * @fires Document#removed\n * @fires Document#updated\n */\n\nclass SyncDocument extends closeable_1.default {\n  // private props\n  get uri() {\n    return this.syncDocumentImpl.uri;\n  }\n\n  get revision() {\n    return this.syncDocumentImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncDocumentImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncDocumentImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncDocumentImpl.type;\n  }\n\n  get type() {\n    return SyncDocumentImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncDocumentImpl.sid;\n  }\n\n  get value() {\n    return this.syncDocumentImpl.value;\n  }\n\n  get dateUpdated() {\n    return this.syncDocumentImpl.dateUpdated;\n  }\n\n  get uniqueName() {\n    return this.syncDocumentImpl.uniqueName;\n  }\n\n  constructor(syncDocumentImpl) {\n    super();\n    this.syncDocumentImpl = syncDocumentImpl;\n    this.syncDocumentImpl.attach(this);\n  }\n  /**\n   * Assign new contents to this document. The current value will be overwritten.\n   * @param {Object} value The new contents to assign.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @returns {Promise<Object>} A promise resolving to the new value of the document.\n   * @public\n   * @example\n   * // Say, the Document value is { name: 'John Smith', age: 34 }\n   * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })\n   *   .then(function(newValue) {\n   *     // Now the Document value is { name: 'Barbara Oaks' }\n   *     console.log('Document set() successful, new value:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document set() failed', error);\n   *   });\n   */\n\n\n  async set(value, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.set(value, metadataUpdates);\n  }\n  /**\n   * Schedules a modification to this document that will apply a mutation function.\n   * @param {Document~Mutator} mutator A function that outputs a new value based on the existing value.\n   * May be called multiple times, particularly if this Document is modified concurrently by remote code.\n   * If the mutation ultimately succeeds, the Document will have made the particular transition described\n   * by this function.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @return {Promise<Object>} Resolves with the most recent Document state, whether the output of a\n   *    successful mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * document.mutate(mutatorFunction, { ttl: 86400 }))\n   *   .then(function(newValue) {\n   *     console.log('Document mutate() successful, new value:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document mutate() failed', error);\n   *   });\n   */\n\n\n  async mutate(mutator, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.mutate(mutator, metadataUpdates);\n  }\n  /**\n   * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.\n   * This is equivalent to\n   * <pre>\n   * document.mutate(function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n   * @param {Document#Metadata} [metadataUpdates] New document metadata.\n   * @return {Promise<Object>} A promise resolving to the new value of the document.\n   * @public\n   * @example\n   * // Say, the Document value is { name: 'John Smith' }\n   * document.update({ age: 34 }, { ttl: 86400 })\n   *   .then(function(newValue) {\n   *     // Now the Document value is { name: 'John Smith', age: 34 }\n   *     console.log('Document update() successful, new value:', newValue);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document update() failed', error);\n   *   });\n   */\n\n\n  async update(obj, metadataUpdates) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.update(obj, metadataUpdates);\n  }\n  /**\n   * Update the time-to-live of the document.\n   * @param {Number} ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * document.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Document setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document setTtl() failed', error);\n   *   });\n   */\n\n\n  async setTtl(ttl) {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.setTtl(ttl);\n  }\n  /**\n   * Delete a document.\n   * @return {Promise<void>} A promise which resolves if (and only if) the document is ultimately deleted.\n   * @public\n   * @example\n   * document.removeDocument()\n   *   .then(function() {\n   *     console.log('Document removeDocument() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Document removeDocument() failed', error);\n   *   });\n   */\n\n\n  async removeDocument() {\n    this.ensureNotClosed();\n    return this.syncDocumentImpl.removeDocument();\n  }\n  /**\n   * Conclude work with the document instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this document will continue operating and receiving events normally.\n   * @public\n   * @example\n   * document.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncDocumentImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncDocument = SyncDocument;\nexports.default = SyncDocument;\n/**\n * Contains Document metadata.\n * @typedef {Object} Document#Metadata\n * @property {String} [ttl] Specifies the time-to-live in seconds after which the document is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the document value.\n * @callback Document~Mutator\n * @param {Object} currentValue The current value of the document in the cloud.\n * @return {Object} The desired new value for the document or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when the document is removed, whether the remover was local or remote.\n * @event Document#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if document was removed by local actor, 'false' otherwise.\n * @example\n * document.on('removed', function(args) {\n *   console.log('Document ' + document.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when the document's contents have changed, whether the updater was local or remote.\n * @event Document#updated\n * @param {Object} args Arguments provided with the event.\n * @param {Object} args.value A snapshot of the document's new contents.\n * @param {Boolean} args.isLocal Equals 'true' if document was updated by local actor, 'false' otherwise.\n * @example\n * document.on('updated', function(args) {\n *   console.log('Document ' + document.sid + ' was updated');\n *   console.log('args.value: ', args.value);\n *   console.log('args.isLocal: ', args.isLocal);\n * });\n */","map":null,"metadata":{},"sourceType":"script"}