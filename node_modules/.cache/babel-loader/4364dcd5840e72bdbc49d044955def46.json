{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass MergingQueue {\n  constructor(inputMergingFunction) {\n    this.queuedRequests = [];\n    this.isRequestInFlight = false;\n    this.inputMergingFunction = inputMergingFunction;\n  }\n\n  add(input, requestFunction) {\n    let promise = new Promise((resolve, reject) => this.queuedRequests.push({\n      input,\n      requestFunction,\n      resolve,\n      reject\n    }));\n    this.wakeupQueue();\n    return promise;\n  }\n\n  squashAndAdd(input, requestFunction) {\n    let queueToSquash = this.queuedRequests;\n    this.queuedRequests = [];\n    let reducedInput;\n\n    if (queueToSquash.length > 0) {\n      reducedInput = queueToSquash.map(r => r.input).reduce(this.inputMergingFunction);\n      reducedInput = this.inputMergingFunction(reducedInput, input);\n    } else {\n      reducedInput = input;\n    }\n\n    let promise = this.add(reducedInput, requestFunction);\n    queueToSquash.forEach(request => promise.then(request.resolve, request.reject));\n    return promise;\n  }\n\n  isEmpty() {\n    return this.queuedRequests.length === 0 && !this.isRequestInFlight;\n  }\n\n  wakeupQueue() {\n    if (this.queuedRequests.length === 0 || this.isRequestInFlight) {\n      return;\n    } else {\n      let requestToExecute = this.queuedRequests.shift();\n      this.isRequestInFlight = true;\n      requestToExecute.requestFunction(requestToExecute.input).then(requestToExecute.resolve, requestToExecute.reject).then(__ => {\n        this.isRequestInFlight = false;\n        this.wakeupQueue();\n      });\n    }\n  }\n\n}\n\nexports.MergingQueue = MergingQueue;\n\nclass NamespacedMergingQueue {\n  constructor(inputReducer) {\n    this.queueByNamespaceKey = new Map();\n    this.inputReducer = inputReducer;\n  }\n\n  async add(namespaceKey, input, requestFunction) {\n    return this.invokeQueueMethod(namespaceKey, queue => queue.add(input, requestFunction));\n  }\n\n  async squashAndAdd(namespaceKey, input, requestFunction) {\n    return this.invokeQueueMethod(namespaceKey, queue => queue.squashAndAdd(input, requestFunction));\n  }\n\n  async invokeQueueMethod(namespaceKey, queueMethodInvoker) {\n    if (!this.queueByNamespaceKey.has(namespaceKey)) {\n      this.queueByNamespaceKey.set(namespaceKey, new MergingQueue(this.inputReducer));\n    }\n\n    const queue = this.queueByNamespaceKey.get(namespaceKey);\n    const result = queueMethodInvoker(queue);\n\n    if (this.queueByNamespaceKey.get(namespaceKey).isEmpty()) {\n      this.queueByNamespaceKey.delete(namespaceKey);\n    }\n\n    return result;\n  }\n\n}\n\nexports.NamespacedMergingQueue = NamespacedMergingQueue;","map":null,"metadata":{},"sourceType":"script"}